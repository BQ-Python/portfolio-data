<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Horizon Labs — Tableau de bord financier</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#050615;
      --accent:#4a90e2;
      --muted:rgba(255,255,255,0.72);
      --card-bg:rgba(255,255,255,0.03);
      --card-strong:rgba(255,255,255,0.06);
      --border:rgba(255,255,255,0.08);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:#fff;background:var(--bg);-webkit-font-smoothing:antialiased;overflow-x:hidden}

    /* NAV */
    nav{position:fixed;top:16px;left:0;right:0;z-index:1200;display:flex;justify-content:center;pointer-events:auto}
    .nav{width:1280px;max-width:96%;display:flex;justify-content:space-between;align-items:center;padding:10px 18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));backdrop-filter:blur(12px);border-radius:8px;border:1px solid var(--border)}
    .brand{font-weight:800;font-size:1.3rem}
    .brand span{color:var(--accent)}
    .links a{color:var(--muted);text-decoration:none;margin-left:20px;font-weight:500;transition:all .25s}
    .links a:hover{color:#fff}
    .links a.disabled{opacity:.5;pointer-events:none}

    /* HERO */
    .hero{min-height:60vh;display:flex;align-items:center;justify-content:center;position:relative;z-index:40;padding:0 20px;text-align:center}
    .hero-inner{max-width:900px;padding:28px;background:linear-gradient(180deg,var(--card-bg),var(--card-strong));border-radius:8px;backdrop-filter:blur(8px);border:1px solid var(--border)}
    h1{font-size:clamp(2rem,4.5vw,3.2rem);line-height:1.1;font-weight:800;margin-bottom:8px}
    .lead{font-size:clamp(1rem,1.8vw,1.1rem);color:var(--muted);margin-bottom:14px}
    .cta{display:inline-block;background:var(--accent);color:#fff;padding:10px 20px;border-radius:6px;font-weight:700;text-decoration:none;transition:all .25s}
    .cta:hover{background:#357abd;box-shadow:0 6px 18px rgba(74,144,226,0.14)}

    /* DASHBOARD */
    .dashboard{position:relative;z-index:50;max-width:1280px;margin:0 auto 80px;padding:40px 20px;display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:20px}
    .kpi{background:linear-gradient(180deg,var(--card-bg),var(--card-strong));border-radius:8px;padding:20px;border:1px solid var(--border);transition:all .25s}
    .kpi:hover{transform:translateY(-4px);box-shadow:0 10px 30px rgba(0,0,0,0.28)}
    .kpi h3{font-size:0.95rem;color:var(--muted);font-weight:500;margin-bottom:8px}
    .kpi .value{font-size:1.6rem;font-weight:800;color:#fff;display:block}
    .kpi.kpi--error{outline:1px solid rgba(231,76,60,0.18);box-shadow:0 6px 18px rgba(231,76,60,0.06) inset}

    /* SEO article */
    #seo-description{grid-column:1 / -1;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:8px;padding:22px;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}

    /* HEATMAP SCENE */
    .scene{position:fixed;inset:0;z-index:0;overflow:hidden;pointer-events:none;background:linear-gradient(180deg,#03040a 0%,#050615 70%)}
    /* overlay sombre pour lisibilité */
    .scene::after{content:"";position:absolute;inset:0;background:rgba(0,0,0,0.62);z-index:2;pointer-events:none}
    canvas#heatmap{position:absolute;inset:0;width:100%;height:100%;z-index:1;display:block}

    @media (max-width:900px){.dashboard{grid-template-columns:1fr;padding:30px 15px;gap:15px}}
  </style>
</head>
<body>

  <div class="scene" aria-hidden="true">
    <canvas id="heatmap" aria-hidden="true"></canvas>
  </div>

  <nav>
    <div class="nav">
      <div class="brand">Horizon<span>Labs</span></div>
      <div class="links">
        <a class="disabled" aria-disabled="true">Accueil</a>
        <a href="portefeuilles.html">Portefeuilles</a>
        <a class="disabled" aria-disabled="true">Analyse</a>
        <a class="disabled" aria-disabled="true">Paramètres</a>
      </div>
    </div>
  </nav>

  <section class="hero">
    <div class="hero-inner">
      <h1>Maîtrise financière, en toute simplicité.</h1>
      <p class="lead">Tableau de bord SaaS pour un survol en temps réel — KPIs essentiels et tendances procédurales.</p>
      <a class="cta" href="portefeuilles.html">Accéder au dashboard</a>
    </div>
  </section>

  <section class="dashboard" aria-live="polite" aria-atomic="true">
    <div class="kpi" id="kpi-wallets">
      <h3>Portefeuilles recensés</h3>
      <span class="value" id="walletsCount">—</span>
    </div>

    <div class="kpi" id="kpi-newsletters">
      <h3>Newsletters référencées</h3>
      <span class="value" id="newslettersCount">—</span>
    </div>

    <div class="kpi" id="kpi-assets">
      <h3>Actifs distincts disponibles</h3>
      <span class="value" id="assetsCount">—</span>
    </div>

    <div class="kpi" id="kpi-visits">
      <h3>Visites ce mois-ci</h3>
      <span class="value" id="visitsCount">1 234</span>
    </div>

    <article id="seo-description">
      <h2 style="color:#fff;margin-bottom:12px;font-size:1.25rem;">À propos de Horizon Labs — Plateforme de gestion de portefeuilles</h2>
      <p>
        Horizon Labs est une solution SaaS dédiée à la <strong>gestion de portefeuilles</strong> et à l’analyse d’actifs financiers.
        Conçue pour les investisseurs individuels et les gestionnaires, la plateforme centralise les portefeuilles, suit les positions
        et fournit des indicateurs clés (KPIs) pour faciliter la prise de décision. Horizon Labs agrège les compositions
        de portefeuilles, identifie les tickers uniques et propose une vue consolidée des actifs (actions, ETF, matières premières).
      </p>
      <h3 style="color:#fff;margin-top:14px;margin-bottom:8px;">Fonctionnalités principales</h3>
      <ul style="color:var(--muted);margin-left:18px;line-height:1.6;">
        <li><strong>Inventaire des portefeuilles</strong> : import automatique depuis des fichiers CSV/JSON pour compter et comparer les portefeuilles.</li>
        <li><strong>Comptage d’actifs uniques</strong> : déduplication des tickers pour connaître l’univers d’investissement réel.</li>
        <li><strong>Suivi des newsletters et sources</strong> : centralisation des flux d’information pour la recherche et la veille.</li>
        <li><strong>KPIs en temps réel</strong> : indicateurs personnalisables pour piloter vos décisions d’investissement.</li>
      </ul>
    </article>
  </section>

  <footer style="position:relative;z-index:10;padding:24px;text-align:center;color:var(--muted);font-size:0.85rem;">© 2025 Horizon Labs — Gestion SaaS privée</footer>

  <script>
    // -------------------------
    // Globals and KPI logic
    // -------------------------
    const el = {
      wallets: document.getElementById('walletsCount'),
      newsletters: document.getElementById('newslettersCount'),
      assetsTotal: document.getElementById('assetsCount'),
      visits: document.getElementById('visitsCount'),
      kpiWalletsCard: document.getElementById('kpi-wallets'),
      kpiAssetsCard: document.getElementById('kpi-assets')
    };

    // Raw URLs (as provided)
    const portfoliosUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/portfolios.json';
    const compositionCsvUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/composition_portefeuilles.csv';
    const newslettersUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/newsletters.json';

    function parseCSV(text){
      const lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
      if(!lines.length) return {headers:[], rows:[]};
      const headerLine = lines[0];
      const delimiter = headerLine.includes('\t') ? '\t' : ',';
      const headers = headerLine.split(delimiter).map(h => h.trim().replace(/^"|"$/g,''));
      const rows = lines.slice(1).map(line=>{
        const values=[]; let cur='', inQuotes=false;
        for(let i=0;i<line.length;i++){
          const ch=line[i];
          if(ch==='"'){ if(inQuotes && line[i+1]==='"'){ cur+='"'; i++; } else { inQuotes=!inQuotes; } continue; }
          if(ch===delimiter && !inQuotes){ values.push(cur); cur=''; continue; }
          cur+=ch;
        }
        values.push(cur);
        return values.map(v=>v.trim().replace(/^"|"$/g,''));
      });
      return {headers, rows};
    }

    async function updateKPIs(){
      // portfolios
      try{
        const res = await fetch(portfoliosUrl, {cache:'no-store'});
        if(!res.ok) throw new Error(`portfolios.json ${res.status}`);
        const data = await res.json();
        let count = 0;
        if(Array.isArray(data)) count = data.length;
        else if(data && typeof data === 'object'){ const arr = Object.values(data).find(v=>Array.isArray(v)); count = Array.isArray(arr)?arr.length:0; }
        el.wallets.textContent = count.toLocaleString('fr-FR');
        el.kpiWalletsCard.classList.remove('kpi--error');
      }catch(err){
        console.warn('Erreur portfolios.json', err);
        el.wallets.textContent = '0';
        el.kpiWalletsCard.classList.add('kpi--error');
      }

      // newsletters
      try{
        const res2 = await fetch(newslettersUrl, {cache:'no-store'});
        if(!res2.ok) throw new Error(`newsletters.json ${res2.status}`);
        const ndata = await res2.json();
        let ncount = 0;
        if(Array.isArray(ndata)) ncount = ndata.length;
        else if(ndata && typeof ndata === 'object'){ const arr = Object.values(ndata).find(v=>Array.isArray(v)); ncount = Array.isArray(arr)?arr.length:0; }
        el.newsletters.textContent = ncount.toLocaleString('fr-FR');
      }catch(err){
        el.newsletters.textContent = '0';
      }

      // composition CSV -> unique tickers
      try{
        const res3 = await fetch(compositionCsvUrl, {cache:'no-store'});
        if(!res3.ok) throw new Error(`composition_portefeuilles.csv ${res3.status}`);
        const csvText = await res3.text();
        const parsed = parseCSV(csvText);
        const headersLower = parsed.headers.map(h=>h.toLowerCase());
        const tickerIdx = headersLower.findIndex(h=>['ticker','symbole','symbol'].includes(h));
        if(tickerIdx === -1){
          console.warn('Ticker column not found', parsed.headers);
          el.assetsTotal.textContent = '0';
          el.kpiAssetsCard.classList.add('kpi--error');
          // set heatmap intensity fallback
          heatmapSetIntensity(6, 0.6);
        } else {
          const tickers = new Set();
          parsed.rows.forEach(row=>{
            const t = (row[tickerIdx]||'').trim();
            if(!t) return;
            tickers.add(t.toUpperCase());
          });
          const total = tickers.size;
          el.assetsTotal.textContent = total.toLocaleString('fr-FR');
          el.kpiAssetsCard.classList.remove('kpi--error');
          // adapt heatmap: more unique tickers -> more blobs / higher intensity
          const blobBase = Math.min(80, Math.max(8, Math.round(8 + total * 0.9)));
          const intensity = Math.min(1.0, 0.25 + Math.log10(Math.max(1,total)) * 0.18);
          heatmapSetIntensity(blobBase, intensity);
        }
      }catch(err){
        console.warn('Erreur composition CSV', err);
        el.assetsTotal.textContent = '0';
        el.kpiAssetsCard.classList.add('kpi--error');
        heatmapSetIntensity(8, 0.5);
      }

      // visits fictive
      if(el.visits) el.visits.textContent = '1 234';
    }

    // initial KPIs
    updateKPIs();
    setInterval(updateKPIs, 30000);

    // -------------------------
    // Heatmap background (procedural blobs + color map)
    // -------------------------
    const canvas = document.getElementById('heatmap');
    const ctx = canvas.getContext('2d');
    let DPR = Math.max(1, devicePixelRatio || 1);
    let W = innerWidth, H = innerHeight;

    function resizeCanvas(){
      DPR = Math.max(1, devicePixelRatio || 1);
      W = innerWidth; H = innerHeight;
      canvas.width = W * DPR;
      canvas.height = H * DPR;
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);
      // reinit grid if needed
      initBlobs();
    }
    window.addEventListener('resize', resizeCanvas);

    // Respect prefers-reduced-motion
    const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    // Blobs state
    let blobs = [];
    let blobCount = 18;
    let globalIntensity = 0.5; // 0..1

    function heatmapSetIntensity(count, intensity){
      blobCount = Math.max(6, Math.round(count));
      globalIntensity = Math.max(0, Math.min(1, intensity));
      initBlobs();
    }

    function rand(min,max){ return min + Math.random()*(max-min); }

    function initBlobs(){
      blobs.length = 0;
      for(let i=0;i<blobCount;i++){
        const size = rand(Math.min(W,H)*0.06, Math.min(W,H)*0.22);
        blobs.push({
          x: Math.random()*W,
          y: Math.random()*H,
          vx: (Math.random()-0.5) * 0.08,
          vy: (Math.random()-0.5) * 0.08,
          r: size,
          baseR: size,
          hue: 200 + Math.random()*120, // blue->red range (200..320)
          alpha: 0.06 + Math.random()*0.18
        });
      }
    }

    // color map: map intensity (0..1) to color gradient (cool -> warm)
    function colorFor(t){
      // t in [0,1]
      // use HSL interpolation from blue (210) to red (10)
      const h = 210 + (10 - 210) * t; // 210 -> 10
      const s = 80;
      const l = 55;
      return `hsl(${h}, ${s}%, ${l}%)`;
    }

    // draw gaussian-like blurred blobs by drawing radial gradients additive
    function drawHeatmap(){
      // clear
      ctx.clearRect(0,0,W,H);

      // draw blobs onto an offscreen canvas for better blending if needed
      // but here we draw directly with globalCompositeOperation 'lighter' to accumulate intensity
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = 'rgba(0,0,0,0)';
      ctx.fillRect(0,0,W,H);

      // accumulate intensity into an intermediate image (grayscale)
      // We'll draw blurred circles with 'lighter' blend and then colorize
      ctx.globalCompositeOperation = 'lighter';
      for(const b of blobs){
        const grd = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r);
        const a = Math.max(0.02, Math.min(0.35, b.alpha * globalIntensity));
        grd.addColorStop(0, `rgba(255,255,255,${a})`);
        grd.addColorStop(0.6, `rgba(255,255,255,${a*0.25})`);
        grd.addColorStop(1, `rgba(255,255,255,0)`);
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fill();
      }

      // read pixels and colorize based on brightness
      const img = ctx.getImageData(0,0,W,H);
      const data = img.data;
      for(let i=0;i<data.length;i+=4){
        // brightness from white channel
        const brightness = data[i]; // red channel (since we drew white)
        if(brightness === 0) continue;
        // normalize 0..255 -> 0..1
        const t = Math.min(1, brightness / 255);
        // map t through a non-linear curve to emphasize hotspots
        const tt = Math.pow(t, 0.9);
        // get color
        const col = hslToRgb(210 + (10-210)*tt, 0.8, 0.55); // hue, s, l
        // blend color with original alpha
        data[i] = Math.min(255, col.r * 255);
        data[i+1] = Math.min(255, col.g * 255);
        data[i+2] = Math.min(255, col.b * 255);
        // set alpha proportional to t and globalIntensity
        data[i+3] = Math.min(220, Math.round(180 * tt * globalIntensity));
      }
      ctx.putImageData(img, 0, 0);

      // subtle vignette to focus center
      const vignette = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.2, W/2, H/2, Math.max(W,H)*0.9);
      vignette.addColorStop(0, 'rgba(0,0,0,0)');
      vignette.addColorStop(1, 'rgba(0,0,0,0.45)');
      ctx.fillStyle = vignette;
      ctx.fillRect(0,0,W,H);
    }

    // helper: convert HSL to normalized rgb object (r,g,b in 0..1)
    function hslToRgb(h, s, l){
      // h in degrees, s/l in 0..1
      h = ((h % 360) + 360) % 360;
      s = Math.max(0, Math.min(1, s));
      l = Math.max(0, Math.min(1, l));
      const c = (1 - Math.abs(2*l - 1)) * s;
      const hp = h / 60;
      const x = c * (1 - Math.abs((hp % 2) - 1));
      let r1=0,g1=0,b1=0;
      if(hp >= 0 && hp < 1){ r1=c; g1=x; b1=0; }
      else if(hp < 2){ r1=x; g1=c; b1=0; }
      else if(hp < 3){ r1=0; g1=c; b1=x; }
      else if(hp < 4){ r1=0; g1=x; b1=c; }
      else if(hp < 5){ r1=x; g1=0; b1=c; }
      else { r1=c; g1=0; b1=x; }
      const m = l - c/2;
      return { r: r1 + m, g: g1 + m, b: b1 + m };
    }

    // animation loop
    let last = performance.now();
    function step(now){
      const dt = now - last;
      last = now;
      // if reduced motion, draw static frame and stop
      if(reduceMotion){
        drawHeatmap();
        return;
      }
      // update blobs
      for(const b of blobs){
        b.x += b.vx * dt * 0.06;
        b.y += b.vy * dt * 0.06;
        // gentle size oscillation
        b.r = b.baseR * (0.9 + 0.12 * Math.sin((now*0.001) + b.baseR));
        // wrap
        if(b.x < -b.r) b.x = W + b.r;
        if(b.x > W + b.r) b.x = -b.r;
        if(b.y < -b.r) b.y = H + b.r;
        if(b.y > H + b.r) b.y = -b.r;
      }
      drawHeatmap();
      requestAnimationFrame(step);
    }

    // initialize
    resizeCanvas();
    initBlobs();
    requestAnimationFrame(step);

    // expose heatmapSetIntensity to KPI loader above
    // (already defined earlier)

    // pause animation when not visible (reduce CPU)
    document.addEventListener('visibilitychange', ()=>{
      if(document.hidden){
        // do nothing; requestAnimationFrame will be throttled by browser
      } else {
        last = performance.now();
        if(!reduceMotion) requestAnimationFrame(step);
      }
    });

    // Accessibility: allow toggling via JS console if needed
    window.heatmapSetIntensity = heatmapSetIntensity;
  </script>
</body>
</html>
