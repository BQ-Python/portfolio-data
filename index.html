<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Horizon Labs — Présentation graphique (sparklines + barres)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#040512;
      --accent:#4a90e2;
      --muted:rgba(255,255,255,0.78);
      --card-bg:rgba(255,255,255,0.03);
      --card-strong:rgba(255,255,255,0.06);
      --border:rgba(255,255,255,0.08);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:#fff;background:var(--bg);-webkit-font-smoothing:antialiased;overflow-x:hidden}

    /* Scene */
    .scene{position:fixed;inset:0;z-index:0;overflow:hidden;pointer-events:none;background:linear-gradient(180deg,#02030a 0%,#040512 70%)}
    .scene::after{content:"";position:absolute;inset:0;background:rgba(0,0,0,0.66);z-index:2;pointer-events:none}
    canvas#hero{position:absolute;inset:0;width:100%;height:100%;z-index:1;display:block}

    /* Layout / Nav */
    nav{position:fixed;top:16px;left:0;right:0;z-index:1200;display:flex;justify-content:center;pointer-events:auto}
    .nav{width:1280px;max-width:96%;display:flex;justify-content:space-between;align-items:center;padding:10px 18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));backdrop-filter:blur(12px);border-radius:8px;border:1px solid var(--border)}
    .brand{font-weight:800;font-size:1.3rem}
    .brand span{color:var(--accent)}
    .links a{color:var(--muted);text-decoration:none;margin-left:20px;font-weight:500;transition:all .25s}
    .links a:hover{color:#fff}

    /* Hero */
    .hero{min-height:56vh;display:flex;align-items:center;justify-content:center;position:relative;z-index:40;padding:0 20px;text-align:center}
    .hero-inner{max-width:980px;padding:36px;background:linear-gradient(180deg,var(--card-bg),var(--card-strong));border-radius:12px;backdrop-filter:blur(10px);border:1px solid var(--border)}
    h1{font-size:clamp(2rem,4.5vw,3.4rem);line-height:1.05;font-weight:800;margin-bottom:8px}
    .lead{font-size:clamp(1rem,1.6vw,1.05rem);color:var(--muted);margin-bottom:14px}

    /* Dashboard KPIs centered */
    .dashboard{position:relative;z-index:50;max-width:1280px;margin:0 auto 80px;padding:28px 20px;display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:18px;align-items:start}
    .kpi{background:linear-gradient(180deg,var(--card-bg),var(--card-strong));border-radius:10px;padding:18px;border:1px solid var(--border);transition:all .25s;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;min-height:84px}
    .kpi h3{font-size:0.95rem;color:var(--muted);font-weight:500;margin-bottom:8px}
    .kpi .value{font-size:1.6rem;font-weight:800;color:#fff;display:block}
    .kpi.kpi--error{outline:1px solid rgba(231,76,60,0.18);box-shadow:0 6px 18px rgba(231,76,60,0.06) inset}

    /* SEO article (restored presentation text) */
    #seo-description{grid-column:1 / -1;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:8px;padding:20px;border:1px solid rgba(255,255,255,0.04);color:var(--muted);line-height:1.5}

    footer{position:relative;z-index:60;padding:24px;text-align:center;color:var(--muted);font-size:0.85rem}

    @media (max-width:900px){
      .hero-inner{padding:20px}
      .dashboard{padding:20px 12px}
      .kpi{min-height:72px}
    }
  </style>
</head>
<body>

  <div class="scene" aria-hidden="true">
    <canvas id="hero" aria-hidden="true"></canvas>
  </div>

  <nav>
    <div class="nav">
      <div class="brand">Horizon<span>Labs</span></div>
      <div class="links">
        <a class="disabled" aria-disabled="true">Accueil</a>
        <a href="portefeuilles.html">Portefeuilles</a>
        <a class="disabled" aria-disabled="true">Analyse</a>
        <a class="disabled" aria-disabled="true">Paramètres</a>
      </div>
    </div>
  </nav>

  <section class="hero">
    <div class="hero-inner">
      <h1>Visuel Présentation — Sparklines & Barres</h1>
      <p class="lead">Peu de lignes marquantes, aires floues et diagrammes en barre en bas : rendu magazine, professionnel et aéré. Les lignes sont distinctes (couleurs, épaisseurs, rythmes) et les barres plus visibles pour mieux représenter le volume.</p>
    </div>
  </section>

  <section class="dashboard" aria-live="polite" aria-atomic="true">
    <div class="kpi" id="kpi-wallets"><h3>Portefeuilles recensés</h3><span class="value" id="walletsCount">—</span></div>
    <div class="kpi" id="kpi-newsletters"><h3>Newsletters référencées</h3><span class="value" id="newslettersCount">—</span></div>
    <div class="kpi" id="kpi-assets"><h3>Actifs distincts disponibles</h3><span class="value" id="assetsCount">—</span></div>
    <div class="kpi" id="kpi-visits"><h3>Visites ce mois-ci</h3><span class="value" id="visitsCount">1 234</span></div>

    <article id="seo-description">
      <h2 style="color:#fff;margin-bottom:10px;font-size:1.15rem;">À propos — Présentation graphique</h2>
      <p>Version mixée : barres en bas + sparklines marquantes par dessus, glow et ombres pour profondeur, densité réduite pour respirer. Idéal pour une page de démonstration ou un hero visuel.</p>
    </article>
  </section>

  <footer>© 2025 Horizon Labs — Gestion SaaS privée</footer>

  <script>
    /* -------------------------
       KPI fetching (URLs raw GitHub)
    ------------------------- */
    const el = {
      wallets: document.getElementById('walletsCount'),
      newsletters: document.getElementById('newslettersCount'),
      assetsTotal: document.getElementById('assetsCount'),
      visits: document.getElementById('visitsCount'),
      kpiWalletsCard: document.getElementById('kpi-wallets'),
      kpiAssetsCard: document.getElementById('kpi-assets')
    };
    const portfoliosUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/portfolios.json';
    const compositionCsvUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/composition_portefeuilles.csv';
    const newslettersUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/newsletters.json';

    function parseCSV(text){
      const lines = text.split(/\r?\n/).filter(l=>l.trim()!=='');
      if(!lines.length) return {headers:[], rows:[]};
      const headerLine = lines[0];
      const delimiter = headerLine.includes('\t') ? '\t' : ',';
      const headers = headerLine.split(delimiter).map(h=>h.trim().replace(/^"|"$/g,''));
      const rows = lines.slice(1).map(line=>{
        const values=[]; let cur='', inQuotes=false;
        for(let i=0;i<line.length;i++){
          const ch=line[i];
          if(ch==='"'){ if(inQuotes && line[i+1]==='"'){ cur+='"'; i++; } else { inQuotes=!inQuotes; } continue; }
          if(ch===delimiter && !inQuotes){ values.push(cur); cur=''; continue; }
          cur+=ch;
        }
        values.push(cur);
        return values.map(v=>v.trim().replace(/^"|"$/g,''));
      });
      return {headers, rows};
    }

    async function updateKPIs(){
      try{
        const res = await fetch(portfoliosUrl, {cache:'no-store'});
        if(!res.ok) throw new Error('portfolios.json '+res.status);
        const data = await res.json();
        let count = Array.isArray(data) ? data.length : (data && typeof data==='object' ? (Object.values(data).find(v=>Array.isArray(v))||[]).length : 0);
        el.wallets.textContent = count.toLocaleString('fr-FR');
        el.kpiWalletsCard.classList.remove('kpi--error');
      }catch(e){ el.wallets.textContent='0'; el.kpiWalletsCard.classList.add('kpi--error'); }

      try{
        const res2 = await fetch(newslettersUrl, {cache:'no-store'});
        if(!res2.ok) throw new Error('newsletters.json '+res2.status);
        const ndata = await res2.json();
        let ncount = Array.isArray(ndata) ? ndata.length : (ndata && typeof ndata==='object' ? (Object.values(ndata).find(v=>Array.isArray(v))||[]).length : 0);
        el.newsletters.textContent = ncount.toLocaleString('fr-FR');
      }catch(e){ el.newsletters.textContent='0'; }

      try{
        const res3 = await fetch(compositionCsvUrl, {cache:'no-store'});
        if(!res3.ok) throw new Error('composition CSV '+res3.status);
        const csvText = await res3.text();
        const parsed = parseCSV(csvText);
        const headersLower = parsed.headers.map(h=>h.toLowerCase());
        const tickerIdx = headersLower.findIndex(h=>['ticker','symbole','symbol'].includes(h));
        if(tickerIdx===-1){ el.assetsTotal.textContent='0'; el.kpiAssetsCard.classList.add('kpi--error'); setVisual(3,0.14,0.18); }
        else {
          const tickers = new Set();
          parsed.rows.forEach(r=>{ const t=(r[tickerIdx]||'').trim(); if(t) tickers.add(t.toUpperCase()); });
          el.assetsTotal.textContent = tickers.size.toLocaleString('fr-FR');
          el.kpiAssetsCard.classList.remove('kpi--error');
          const lines = Math.min(5, Math.max(3, Math.round(3 + tickers.size * 0.03)));
          const amp = Math.min(0.5, 0.10 + Math.log10(Math.max(1,tickers.size)) * 0.03);
          const blob = Math.min(0.9, 0.12 + Math.log10(Math.max(1,tickers.size)) * 0.05);
          setVisual(lines, amp, blob);
        }
      }catch(e){ el.assetsTotal.textContent='0'; el.kpiAssetsCard.classList.add('kpi--error'); setVisual(3,0.14,0.18); }

      if(el.visits) el.visits.textContent = '1 234';
    }
    updateKPIs();
    setInterval(updateKPIs, 30000);

    /* -------------------------
       Canvas hero: sparklines + bar chart bottom (improved)
    ------------------------- */
    const canvas = document.getElementById('hero');
    const ctx = canvas.getContext('2d', { alpha: true });
    let DPR = Math.max(1, devicePixelRatio || 1);
    let W = innerWidth, H = innerHeight;
    const POINTS = 160;

    // visual params (presentation preset)
    let VIS = { lines: 3, amplitudeFactor: 0.12, blobIntensity: 0.18 };

    function setVisual(lines, amp, blobInt){
      VIS.lines = Math.max(3, Math.min(6, Math.round(lines)));
      VIS.amplitudeFactor = Math.max(0.06, Math.min(0.6, amp));
      VIS.blobIntensity = Math.max(0, Math.min(1, blobInt));
      initScene();
    }

    const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    function resize(){
      DPR = Math.max(1, devicePixelRatio || 1);
      W = innerWidth; H = innerHeight;
      canvas.width = Math.round(W * DPR);
      canvas.height = Math.round(H * DPR);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);
      initScene();
    }
    window.addEventListener('resize', resize);

    // blobs
    let blobs = [];
    function initBlobs(){
      blobs = [];
      const count = 3;
      for(let i=0;i<count;i++){
        const size = Math.min(W,H) * (0.45 + Math.random()*0.35);
        blobs.push({ x: Math.random()*W, y: Math.random()*H*0.7, r: size, hue: 200 + Math.random()*80, alpha: 0.06 + Math.random()*0.12, vx:(Math.random()-0.5)*0.02, vy:(Math.random()-0.5)*0.02 });
      }
    }

    // bars (bottom chart) — fewer, wider, more visible
    let bars = [];
    function initBars(){
      bars = [];
      const count = Math.max(12, Math.round(W / 120)); // fewer bars, wider
      for(let i=0;i<count;i++){
        bars.push({
          x: (i + 0.5) * (W / count),
          w: Math.max(10, Math.floor(W / count * 0.7)),
          h: (0.12 + Math.random()*0.6) * (H * 0.18),
          hue: 200 + Math.random()*80,
          alpha: 0.18 + Math.random()*0.22 // stronger alpha for visibility
        });
      }
    }

    // sparklines — fewer and more distinct
    let lines = [];
    function initLines(){
      lines = [];
      const marginTop = Math.max(120, H * 0.08);
      const marginBottom = Math.max(220, H * 0.18); // leave space for bars
      const usable = Math.max(200, H - marginTop - marginBottom);
      const spacing = usable / Math.max(1, VIS.lines - 1);
      for(let i=0;i<VIS.lines;i++){
        const yBase = marginTop + i * spacing;
        // make each line visually distinct: different thickness, hue and base frequency
        const thickness = 2.8 + i * 0.6; // progressive thickness
        const phase = Math.random()*Math.PI*2;
        const speed = 0.00025 + Math.random()*0.0009;
        const amplitude = VIS.amplitudeFactor * (0.9 + Math.random()*0.6) * spacing;
        const colorHue = 200 + i * 22; // larger hue shift for distinction
        const freq = 1 + i * 0.6; // different frequency per line
        const base = new Float32Array(POINTS);
        for(let p=0;p<POINTS;p++) base[p] = Math.sin((p/POINTS)*Math.PI*2*freq) * (0.4 + Math.random()*0.8);
        lines.push({ yBase, thickness, phase, speed, amplitude, base, colorHue, freq });
      }
    }

    // animated points
    let animatedPoints = [];
    function initPoints(){
      animatedPoints = [];
      for(let i=0;i<lines.length;i++){
        animatedPoints.push({ lineIdx:i, xIndex: Math.floor(Math.random()*POINTS), phase: Math.random()*Math.PI*2, speed: 0.0008 + Math.random()*0.002 });
      }
    }

    function initScene(){
      initBlobs();
      initBars();
      initLines();
      initPoints();
    }

    // draw helpers
    function drawBlobs(now){
      for(const b of blobs){
        b.x += b.vx * (now * 0.00002);
        b.y += b.vy * (now * 0.00002);
        if(b.x < -b.r) b.x = W + b.r;
        if(b.x > W + b.r) b.x = -b.r;
        if(b.y < -b.r) b.y = H + b.r;
        if(b.y > H + b.r) b.y = -b.r;
        const grd = ctx.createRadialGradient(b.x, b.y, b.r*0.05, b.x, b.y, b.r);
        const hue = b.hue; const alpha = b.alpha * VIS.blobIntensity;
        grd.addColorStop(0, `hsla(${hue},90%,70%,${alpha*0.95})`);
        grd.addColorStop(0.25, `hsla(${hue},85%,60%,${alpha*0.6})`);
        grd.addColorStop(0.6, `hsla(${hue},80%,50%,${alpha*0.18})`);
        grd.addColorStop(1, `hsla(${hue},80%,40%,0)`);
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = grd;
        ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
      }
    }

    function drawBars(){
      const baseY = H - 48;
      for(const bar of bars){
        // subtle vertical gradient for bars
        const g = ctx.createLinearGradient(bar.x - bar.w/2, baseY - bar.h, bar.x - bar.w/2, baseY);
        g.addColorStop(0, `hsla(${bar.hue},85%,70%,${Math.min(0.28, bar.alpha)})`);
        g.addColorStop(1, `hsla(${bar.hue},80%,45%,${Math.min(0.12, bar.alpha*0.6)})`);
        ctx.save();
        ctx.shadowColor = `rgba(0,0,0,0.32)`;
        ctx.shadowBlur = 10;
        ctx.shadowOffsetY = 6;
        ctx.fillStyle = g;
        ctx.fillRect(bar.x - bar.w/2, baseY - bar.h, bar.w, bar.h);
        ctx.restore();
        // thin stroke to make bars readable
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = `rgba(255,255,255,0.06)`;
        ctx.strokeRect(bar.x - bar.w/2 + 0.5, baseY - bar.h + 0.5, bar.w - 1, bar.h - 1);
        // top highlight
        ctx.fillStyle = `hsla(${bar.hue},95%,88%,${Math.min(0.14, bar.alpha*0.9)})`;
        ctx.fillRect(bar.x - bar.w/2, baseY - bar.h - 2, bar.w, 2);
      }
    }

    function drawLines(now){
      for(let i=0;i<lines.length;i++){
        const s = lines[i];
        const t = now * s.speed;
        const stepX = W / (POINTS - 1);
        // compute points
        const pts = new Array(POINTS);
        for(let p=0;p<POINTS;p++){
          const noise = s.base[p] * (0.45 + 0.55 * Math.sin(t + p * 0.12 + s.phase));
          const x = p * stepX;
          const y = s.yBase + noise * s.amplitude;
          pts[p] = {x,y};
        }
        // area path
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let p=1;p<POINTS;p++) ctx.lineTo(pts[p].x, pts[p].y);
        const baseline = s.yBase + s.amplitude * 1.8;
        ctx.lineTo(W, baseline); ctx.lineTo(0, baseline); ctx.closePath();
        // shadow under area
        ctx.save();
        ctx.shadowColor = `rgba(6,18,40,0.20)`;
        ctx.shadowBlur = 28;
        ctx.shadowOffsetY = 10;
        const fillGrad = ctx.createLinearGradient(0, s.yBase - s.amplitude, 0, baseline);
        fillGrad.addColorStop(0, `hsla(${s.colorHue},85%,65%,0.18)`);
        fillGrad.addColorStop(1, `hsla(${s.colorHue},80%,45%,0.02)`);
        ctx.fillStyle = fillGrad;
        ctx.fill();
        ctx.restore();
        // glow stroke (outer)
        ctx.save();
        ctx.lineJoin = 'round'; ctx.lineCap = 'round';
        ctx.lineWidth = s.thickness + 2.4;
        ctx.shadowColor = `hsla(${s.colorHue},90%,70%,0.20)`;
        ctx.shadowBlur = 30;
        ctx.strokeStyle = `hsla(${s.colorHue},90%,70%,0.16)`;
        ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
        for(let p=1;p<POINTS;p++) ctx.lineTo(pts[p].x, pts[p].y);
        ctx.stroke();
        ctx.restore();
        // crisp inner stroke with distinct color per line
        ctx.beginPath();
        ctx.lineWidth = Math.max(1.6, s.thickness * 0.95);
        ctx.strokeStyle = `hsla(${s.colorHue},95%,92%,0.98)`;
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let p=1;p<POINTS;p++) ctx.lineTo(pts[p].x, pts[p].y);
        ctx.stroke();
        // thin accent (slightly shifted) to add depth
        ctx.beginPath();
        ctx.lineWidth = Math.max(0.9, s.thickness * 0.45);
        ctx.strokeStyle = `hsla(${s.colorHue},95%,80%,0.14)`;
        ctx.moveTo(pts[0].x, pts[0].y - 0.8);
        for(let p=1;p<POINTS;p++) ctx.lineTo(pts[p].x, pts[p].y - 0.8);
        ctx.stroke();
      }
    }

    function drawAnimatedPoints(now){
      for(const ap of animatedPoints){
        const s = lines[ap.lineIdx];
        ap.phase += ap.speed * (now * 0.00002);
        const idx = (Math.floor((ap.xIndex + Math.sin(ap.phase) * 6 + now * 0.00002) + POINTS)) % POINTS;
        const stepX = W / (POINTS - 1);
        const noise = s.base[idx] * (0.45 + 0.55 * Math.sin(now * s.speed + idx * 0.12 + s.phase));
        const x = idx * stepX;
        const y = s.yBase + noise * s.amplitude;
        // glow dot
        ctx.save();
        ctx.beginPath();
        ctx.shadowColor = `hsla(${s.colorHue},95%,75%,0.34)`;
        ctx.shadowBlur = 22;
        ctx.fillStyle = `hsla(${s.colorHue},95%,75%,0.98)`;
        ctx.arc(x,y,6.0,0,Math.PI*2); ctx.fill();
        ctx.restore();
        // crisp center
        ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.98)'; ctx.arc(x,y,1.8,0,Math.PI*2); ctx.fill();
      }
    }

    // render loop
    let last = performance.now();
    function render(now){
      const dt = now - last;
      last = now;
      ctx.clearRect(0,0,W,H);
      // background blobs
      drawBlobs(now);
      // bars (bottom)
      drawBars();
      // lines above bars
      drawLines(now);
      // animated points
      drawAnimatedPoints(now);
      // vignette
      const vign = ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.12,W/2,H/2,Math.max(W,H)*0.9);
      vign.addColorStop(0,'rgba(0,0,0,0)'); vign.addColorStop(1,'rgba(0,0,0,0.45)');
      ctx.fillStyle = vign; ctx.fillRect(0,0,W,H);
      if(!reduceMotion) requestAnimationFrame(render);
    }

    // init & start
    function start(){
      resize();
      initScene();
      last = performance.now();
      if(reduceMotion) render(last);
      else requestAnimationFrame(render);
    }
    window.setVisual = setVisual;
    start();

    // visibility handling
    document.addEventListener('visibilitychange', ()=>{
      if(document.hidden) { /* browser throttles */ }
      else { last = performance.now(); if(!reduceMotion) requestAnimationFrame(render); }
    });
  </script>
</body>
</html>
