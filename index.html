<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Horizon Labs — Tableau de bord financier</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <style>
    :root {
      --bg: #0a0f1f;
      --accent: #4a90e2;
      --gain: #4cd07d;
      --loss: #e74c3c;
      --muted: rgba(255,255,255,0.7);
      --card-bg: rgba(255,255,255,0.03);
      --border: rgba(255,255,255,0.08);
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body { font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color: #fff; background: var(--bg); -webkit-font-smoothing: antialiased; overflow-x: hidden; }

    /* NAV */
    nav { position: fixed; top: 16px; left: 0; right: 0; z-index: 1200; display: flex; justify-content: center; pointer-events: auto; }
    .nav { width: 1280px; max-width: 96%; display: flex; justify-content: space-between; align-items: center; padding: 10px 18px; background: var(--card-bg); backdrop-filter: blur(12px); border-radius: 8px; border: 1px solid var(--border); }
    .brand { font-weight: 800; font-size: 1.3rem; }
    .brand span { color: var(--accent); }
    .links a { color: var(--muted); text-decoration: none; margin-left: 20px; font-weight: 500; transition: all .3s; }
    .links a:hover { color: #fff; }
    .links a.disabled { opacity: .5; cursor: default; pointer-events: none; }

    /* HERO */
    .hero { min-height: 60vh; display: flex; align-items: center; justify-content: center; position: relative; z-index: 10; padding: 0 20px; text-align: center; }
    .hero-inner { max-width: 900px; padding: 28px; background: var(--card-bg); border-radius: 8px; backdrop-filter: blur(8px); border: 1px solid var(--border); }
    h1 { font-size: clamp(2rem, 4.5vw, 3.2rem); line-height: 1.1; font-weight: 800; margin-bottom: 8px; }
    .lead { font-size: clamp(1rem, 1.8vw, 1.1rem); color: var(--muted); margin-bottom: 14px; }
    .cta { display: inline-block; background: var(--accent); color: #fff; padding: 10px 20px; border-radius: 6px; font-weight: 700; text-decoration: none; transition: all .3s; }
    .cta:hover { background: #357abd; box-shadow: 0 4px 12px rgba(74,144,226,0.2); }

    /* DASHBOARD */
    .dashboard { position: relative; z-index: 20; max-width: 1280px; margin: 0 auto 80px; padding: 40px 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 20px; }
    .kpi { background: var(--card-bg); border-radius: 8px; padding: 20px; border: 1px solid var(--border); transition: all .3s; pointer-events: auto; }
    .kpi:hover { transform: translateY(-4px); box-shadow: 0 8px 24px rgba(0,0,0,0.15); }
    .kpi h3 { font-size: 0.95rem; color: var(--muted); font-weight: 500; margin-bottom: 8px; }
    .kpi .value { font-size: 1.6rem; font-weight: 800; color: #fff; display: block; }
    .kpi .sub { font-size: 0.9rem; color: var(--muted); margin-top: 6px; }
    .kpi.kpi--error { outline: 1px solid rgba(231,76,60,0.18); box-shadow: 0 6px 18px rgba(231,76,60,0.06) inset; }

    /* SCENE */
    .scene { position: fixed; inset: 0; z-index: 0; overflow: hidden; pointer-events: none; background: linear-gradient(180deg, var(--bg) 0%, #060b1a 60%); }
    svg#svgScene { position: absolute; inset: 0; width: 100%; height: 100%; display: block; z-index: 0; }
    canvas#bars, canvas#particles { position: absolute; inset: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
    .ticker { position: fixed; left: 0; right: 0; bottom: 16px; z-index: 30; pointer-events: none; display: flex; justify-content: center; }
    .ticker .line { background: var(--card-bg); color: var(--muted); padding: 6px 12px; border-radius: 999px; font-weight: 500; font-size: 0.9rem; backdrop-filter: blur(8px); border: 1px solid var(--border); }

    /* RESPONSIVE */
    @media (max-width: 900px) {
      .nav { padding: 8px; }
      .links a { margin-left: 12px; font-size: 0.95rem; }
      .hero-inner { padding: 20px; }
      .ticker .line { font-size: 0.85rem; padding: 5px 10px; }
      .dashboard { grid-template-columns: 1fr; padding: 30px 15px; gap: 15px; }
    }
  </style>
</head>
<body>

  <div class="scene" aria-hidden="true">
    <svg id="svgScene" viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid slice" aria-hidden="true">
      <defs>
        <linearGradient id="gradBG" x1="0" x2="0" y1="0" y2="1">
          <stop offset="0%" stop-color="var(--bg)"/>
          <stop offset="100%" stop-color="#060b1a"/>
        </linearGradient>
        <radialGradient id="coinGrad" cx="30%" cy="30%" r="60%">
          <stop offset="0%" stop-color="#e6f0ff"/>
          <stop offset="40%" stop-color="#a8d1ff"/>
          <stop offset="100%" stop-color="#4a90e2"/>
        </radialGradient>
      </defs>
      <rect width="100%" height="100%" fill="url(#gradBG)"></rect>
      <g id="coinsLayer"></g>
      <path id="graphLine" d="" fill="none" stroke="var(--accent)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.9"></path>
      <g id="grid" opacity="0.04"></g>
    </svg>
    <canvas id="bars"></canvas>
    <canvas id="particles"></canvas>
  </div>

  <div class="ticker" aria-hidden="true"><div class="line" id="tickerText">S&P 500 ▲ 0.42% • BTC/USD ▲ 1.2% • EUR/USD ▼ 0.03% • NASDAQ ▲ 0.65%</div></div>

  <!-- Navigation -->
  <nav>
    <div class="nav">
      <div class="brand">Horizon<span>Labs</span></div>
      <div class="links">
        <a class="disabled" aria-disabled="true">Accueil</a>
        <a href="portefeuilles.html">Portefeuilles</a>
        <a class="disabled" aria-disabled="true">Analyse</a>
        <a class="disabled" aria-disabled="true">Paramètres</a>
      </div>
    </div>
  </nav>

  <!-- Hero -->
  <section class="hero">
    <div class="hero-inner">
      <h1>Maîtrise financière, en toute simplicité.</h1>
      <p class="lead">Tableau de bord SaaS pour un survol en temps réel — KPIs essentiels et tendances procédurales.</p>
      <a class="cta" href="portefeuilles.html">Accéder au dashboard</a>
    </div>
  </section>

  <!-- Dashboard KPIs + SEO text -->
  <section class="dashboard" aria-live="polite" aria-atomic="true">
    <div class="kpi" id="kpi-wallets">
      <h3>Portefeuilles recensés</h3>
      <span class="value" id="walletsCount">—</span>
      <div class="sub">Comptage des portefeuilles dans <code>portfolios.json</code></div>
    </div>

    <div class="kpi" id="kpi-newsletters">
      <h3>Newsletters référencées</h3>
      <span class="value" id="newslettersCount">—</span>
      <div class="sub">Fichier attendu : <code>newsletters.json</code> (sera ajouté plus tard)</div>
    </div>

    <div class="kpi" id="kpi-assets">
      <h3>Actifs distincts disponibles</h3>
      <span class="value" id="assetsCount">—</span>
      <div class="sub" id="assetsBreakdown">Actions: — • ETF: — • Matières premières: —</div>
    </div>

    <article id="seo-description" style="grid-column: 1 / -1; background: rgba(255,255,255,0.02); border-radius:8px; padding:22px; border:1px solid rgba(255,255,255,0.04); color:var(--muted);">
      <h2 style="color:#fff; margin-bottom:12px; font-size:1.25rem;">À propos de Horizon Labs — Plateforme de gestion de portefeuilles</h2>

      <p>
        Horizon Labs est une solution SaaS dédiée à la <strong>gestion de portefeuilles</strong> et à l’analyse d’actifs financiers.
        Conçue pour les investisseurs individuels et les gestionnaires, la plateforme centralise les portefeuilles, suit les positions
        et fournit des indicateurs clés (KPIs) pour faciliter la prise de décision. Horizon Labs agrège les compositions
        de portefeuilles, identifie les tickers uniques et propose une vue consolidée des actifs (actions, ETF, matières premières).
      </p>

      <h3 style="color:#fff; margin-top:14px; margin-bottom:8px;">Fonctionnalités principales</h3>
      <ul style="color:var(--muted); margin-left:18px; line-height:1.6;">
        <li><strong>Inventaire des portefeuilles</strong> : import automatique depuis des fichiers CSV/JSON pour compter et comparer les portefeuilles.</li>
        <li><strong>Comptage d’actifs uniques</strong> : déduplication des tickers pour connaître l’univers d’investissement réel.</li>
        <li><strong>Suivi des newsletters et sources</strong> : centralisation des flux d’information pour la recherche et la veille.</li>
        <li><strong>KPIs en temps réel</strong> : indicateurs personnalisables pour piloter vos décisions d’investissement.</li>
      </ul>

      <h3 style="color:#fff; margin-top:14px; margin-bottom:8px;">Pourquoi choisir Horizon Labs</h3>
      <p style="color:var(--muted); line-height:1.6;">
        Horizon Labs simplifie la gestion multi‑portefeuilles en offrant une interface claire et des métriques exploitables.
        La plateforme est optimisée pour la performance et la sécurité des données, et permet d’importer facilement des fichiers
        standards (CSV, JSON). Que vous soyez un investisseur particulier ou une petite équipe de gestion, Horizon Labs réduit
        le temps consacré à la consolidation des données et augmente la qualité des décisions d’investissement.
      </p>

      <h3 style="color:#fff; margin-top:14px; margin-bottom:8px;">Mots‑clés SEO recommandés</h3>
      <p style="color:var(--muted); line-height:1.6;">
        gestion de portefeuille, suivi d'actifs, plateforme SaaS finance, comptage tickers, consolidation portefeuilles, KPIs financiers,
        analyse d'actifs, import CSV portefeuille.
      </p>
    </article>
  </section>

  <footer style="position:relative;z-index:10;padding:24px;text-align:center;color:var(--muted);font-size:0.85rem;">© 2025 Horizon Labs — Gestion SaaS privée</footer>

  <script>
    // --- Globals declared early to avoid TDZ ---
    const bars = [];
    const particles = [];

    const barsCanvas = document.getElementById('bars');
    const barsCtx = barsCanvas ? barsCanvas.getContext('2d') : null;
    const partCanvas = document.getElementById('particles');
    const partCtx = partCanvas ? partCanvas.getContext('2d') : null;
    const svg = document.getElementById('svgScene');
    const coinsLayer = document.getElementById('coinsLayer');
    const graphLine = document.getElementById('graphLine');
    const grid = document.getElementById('grid');
    const tickerText = document.getElementById('tickerText');

    const css = getComputedStyle(document.documentElement);
    function cssColor(name) { return css.getPropertyValue(name).trim() || '#fff'; }
    let gainColor = cssColor('--gain') || '#4cd07d';
    let lossColor = cssColor('--loss') || '#e74c3c';
    let accentColor = cssColor('--accent') || '#4a90e2';
    // --- End globals ---

    // KPI elements
    const el = {
      wallets: document.getElementById('walletsCount'),
      newsletters: document.getElementById('newslettersCount'),
      assetsTotal: document.getElementById('assetsCount'),
      assetsBreakdown: document.getElementById('assetsBreakdown'),
      kpiWalletsCard: document.getElementById('kpi-wallets'),
      kpiAssetsCard: document.getElementById('kpi-assets')
    };

    // Use the raw URLs provided (absolute raw GitHub URLs)
    const portfoliosUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/portfolios.json';
    // CSV assumed to be in same repo under this exact name
    const compositionCsvUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/composition_portefeuilles.csv';
    // newsletters optional (not provided)
    const newslettersUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/newsletters.json';

    // CSV parser (detects tab or comma)
    function parseCSV(text) {
      const lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
      if (!lines.length) return { headers: [], rows: [] };
      const headerLine = lines[0];
      const delimiter = headerLine.includes('\t') ? '\t' : ',';
      const headers = headerLine.split(delimiter).map(h => h.trim().replace(/^"|"$/g, ''));
      const rows = lines.slice(1).map(line => {
        const values = [];
        let cur = '', inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          const ch = line[i];
          if (ch === '"') {
            if (inQuotes && line[i+1] === '"') { cur += '"'; i++; } else { inQuotes = !inQuotes; }
            continue;
          }
          if (ch === delimiter && !inQuotes) { values.push(cur); cur = ''; continue; }
          cur += ch;
        }
        values.push(cur);
        return values.map(v => v.trim().replace(/^"|"$/g, ''));
      });
      return { headers, rows };
    }

    // Update KPIs using the provided raw URLs
    async function updateKPIs() {
      // portfolios.json
      try {
        const res = await fetch(portfoliosUrl, { cache: 'no-store' });
        if (!res.ok) throw new Error(`portfolios.json ${res.status}`);
        const data = await res.json();
        let count = 0;
        if (Array.isArray(data)) count = data.length;
        else if (data && typeof data === 'object') {
          const arr = Object.values(data).find(v => Array.isArray(v));
          count = Array.isArray(arr) ? arr.length : 0;
        }
        el.wallets.textContent = count.toLocaleString('fr-FR');
        el.kpiWalletsCard.classList.remove('kpi--error');
      } catch (err) {
        console.warn('Erreur lecture portfolios.json depuis GitHub raw URL :', err);
        el.wallets.textContent = '0';
        el.kpiWalletsCard.classList.add('kpi--error');
      }

      // newsletters.json (optional)
      try {
        const res2 = await fetch(newslettersUrl, { cache: 'no-store' });
        if (!res2.ok) throw new Error(`newsletters.json ${res2.status}`);
        const ndata = await res2.json();
        let ncount = 0;
        if (Array.isArray(ndata)) ncount = ndata.length;
        else if (ndata && typeof ndata === 'object') {
          const arr = Object.values(ndata).find(v => Array.isArray(v));
          ncount = Array.isArray(arr) ? arr.length : 0;
        }
        el.newsletters.textContent = ncount.toLocaleString('fr-FR');
      } catch (err) {
        el.newsletters.textContent = '0';
      }

      // composition CSV -> count unique tickers
      try {
        const res3 = await fetch(compositionCsvUrl, { cache: 'no-store' });
        if (!res3.ok) throw new Error(`composition_portefeuilles.csv ${res3.status}`);
        const csvText = await res3.text();
        const parsed = parseCSV(csvText);
        const headersLower = parsed.headers.map(h => h.toLowerCase());
        const tickerIdx = headersLower.findIndex(h => ['ticker','symbole','symbol'].includes(h));
        if (tickerIdx === -1) {
          console.warn('Colonne "Ticker" introuvable dans composition_portefeuilles.csv. Entêtes:', parsed.headers);
          el.assetsTotal.textContent = '0';
          el.assetsBreakdown.textContent = 'Actions: — • ETF: — • Matières premières: —';
          el.kpiAssetsCard.classList.add('kpi--error');
        } else {
          const tickers = new Set();
          const typeIdx = headersLower.findIndex(h => ['type','assettype','asset_type','categorie','category'].includes(h));
          const seenType = new Map();
          parsed.rows.forEach(row => {
            const t = (row[tickerIdx] || '').trim();
            if (!t) return;
            const up = t.toUpperCase();
            tickers.add(up);
            if (typeIdx !== -1) {
              const typ = (row[typeIdx] || '').trim().toLowerCase();
              if (!seenType.has(up)) seenType.set(up, typ);
            }
          });
          el.assetsTotal.textContent = tickers.size.toLocaleString('fr-FR');
          if (typeIdx !== -1) {
            const counts = { stock: 0, etf: 0, commodity: 0, other: 0 };
            for (const typ of seenType.values()) {
              if (!typ) { counts.other++; continue; }
              if (typ.includes('etf')) counts.etf++;
              else if (typ.includes('commodity') || typ.includes('mati')) counts.commodity++;
              else if (typ.includes('stock') || typ.includes('action') || typ.includes('equity')) counts.stock++;
              else counts.other++;
            }
            el.assetsBreakdown.textContent = `Actions: ${counts.stock} • ETF: ${counts.etf} • Matières premières: ${counts.commodity}`;
          } else {
            el.assetsBreakdown.textContent = `Actions: — • ETF: — • Matières premières: —`;
          }
          el.kpiAssetsCard.classList.remove('kpi--error');
        }
      } catch (err) {
        console.warn('Erreur lecture composition_portefeuilles.csv depuis GitHub raw URL :', err);
        el.assetsTotal.textContent = '0';
        el.assetsBreakdown.textContent = `Actions: — • ETF: — • Matières premières: —`;
        el.kpiAssetsCard.classList.add('kpi--error');
      }
    }

    // initial load + polling
    updateKPIs();
    setInterval(updateKPIs, 30000);

    /* ---------------------------
       Background animation (bars, particles, coins)
       All globals declared above to avoid TDZ
    --------------------------- */

    let DPR = Math.max(1, devicePixelRatio || 1);

    function resize() {
      DPR = Math.max(1, devicePixelRatio || 1);
      if (barsCanvas && barsCtx) {
        barsCanvas.width = innerWidth * DPR;
        barsCanvas.height = innerHeight * DPR;
        barsCanvas.style.width = innerWidth + 'px';
        barsCanvas.style.height = innerHeight + 'px';
        barsCtx.setTransform(DPR, 0, 0, DPR, 0, 0);
      }
      if (partCanvas && partCtx) {
        partCanvas.width = innerWidth * DPR;
        partCanvas.height = innerHeight * DPR;
        partCanvas.style.width = innerWidth + 'px';
        partCanvas.style.height = innerHeight + 'px';
        partCtx.setTransform(DPR, 0, 0, DPR, 0, 0);
      }
      if (svg) svg.setAttribute('viewBox', `0 0 ${innerWidth} ${innerHeight}`);
      initBars();
      buildGrid();
    }
    window.addEventListener('resize', resize);

    function initBars() {
      bars.length = 0;
      const cols = Math.max(8, Math.floor(innerWidth / 90));
      for (let i = 0; i < cols; i++) {
        bars.push({
          x: (i + 0.5) * (innerWidth / cols),
          width: Math.min(50, innerWidth / cols * 0.5),
          base: innerHeight * 0.82,
          height: (0.08 + Math.random() * 0.5) * innerHeight * 0.35,
          color: Math.random() > 0.5 ? gainColor : lossColor,
          phase: Math.random() * Math.PI * 2,
          speed: 0.8 + Math.random() * 1.6
        });
      }
    }

    function buildGrid() {
      if (!grid) return;
      grid.innerHTML = '';
      const rows = 6;
      for (let i = 0; i <= rows; i++) {
        const y = (i / rows) * innerHeight;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', 0);
        line.setAttribute('y1', y);
        line.setAttribute('x2', innerWidth);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', 'rgba(255,255,255,0.03)');
        line.setAttribute('stroke-width', '1');
        grid.appendChild(line);
      }
    }

    function initParticles() {
      particles.length = 0;
      const count = Math.max(24, Math.floor(innerWidth / 60));
      for (let i = 0; i < count; i++) {
        particles.push({
          x: Math.random() * innerWidth,
          y: Math.random() * innerHeight,
          vx: (Math.random() - 0.5) * 0.2,
          vy: -0.1 - Math.random() * 0.6,
          size: 1 + Math.random() * 3,
          alpha: 0.08 + Math.random() * 0.18,
          color: Math.random() > 0.6 ? gainColor : 'rgba(255,255,255,0.06)'
        });
      }
    }

    function createCoins() {
      if (!coinsLayer) return;
      coinsLayer.innerHTML = '';
      const count = Math.min(10, Math.floor(innerWidth / 220));
      for (let i = 0; i < count; i++) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('class', 'coin');
        const cx = Math.random() * innerWidth;
        const cy = Math.random() * innerHeight * 0.6;
        const r = 28 + Math.random() * 36;

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', cx);
        circle.setAttribute('cy', cy);
        circle.setAttribute('r', r);
        circle.setAttribute('fill', 'url(#coinGrad)');
        circle.setAttribute('opacity', 0.95);
        circle.setAttribute('transform-origin', `${cx}px ${cy}px`);

        const rim = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        rim.setAttribute('cx', cx);
        rim.setAttribute('cy', cy);
        rim.setAttribute('r', r * 0.7);
        rim.setAttribute('fill', 'rgba(255,255,255,0.06)');

        g.appendChild(circle);
        g.appendChild(rim);
        coinsLayer.appendChild(g);

        gsap.to(g, {
          y: '+= ' + (10 + Math.random() * 30),
          rotation: (Math.random() > 0.5 ? 1 : -1) * (6 + Math.random() * 12),
          duration: 4 + Math.random() * 6,
          yoyo: true,
          repeat: -1,
          ease: 'sine.inOut',
          delay: Math.random() * 2
        });
        gsap.to(g, {
          x: '+= ' + (Math.random() - 0.5) * 40,
          duration: 6 + Math.random() * 6,
          yoyo: true,
          repeat: -1,
          ease: 'sine.inOut'
        });
      }
    }

    function roundRect(ctx, x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + w, y, x + w, y + h, radius);
      ctx.arcTo(x + w, y + h, x, y + h, radius);
      ctx.arcTo(x, y + h, x, y, radius);
      ctx.arcTo(x, y, x + w, y, radius);
      ctx.closePath();
      ctx.fill();
    }

    function drawBars(time) {
      if (!barsCtx) return;
      barsCtx.clearRect(0, 0, innerWidth, innerHeight);
      const points = [];
      for (let i = 0; i < bars.length; i++) {
        const b = bars[i];
        const oscill = 0.5 + 0.5 * Math.sin(b.phase + time * 0.001 * b.speed);
        const h = b.height * (0.6 + oscill * 0.8);
        const top = b.base - h;
        const grad = barsCtx.createLinearGradient(b.x, top, b.x, b.base);
        grad.addColorStop(0, hexToRgba(b.color, 0.95));
        grad.addColorStop(1, hexToRgba(b.color, 0.18));
        barsCtx.fillStyle = grad;
        barsCtx.strokeStyle = hexToRgba('#000', 0.06);
        barsCtx.lineWidth = 1;
        roundRect(barsCtx, b.x - b.width / 2, top, b.width, h, 6);
        barsCtx.stroke();
        barsCtx.fillStyle = hexToRgba('#fff', 0.02);
        barsCtx.fillRect(b.x - b.width / 2, top - 2, b.width, 2);
        points.push({ x: b.x, y: top + h * 0.25 });
      }
      if (points.length && graphLine) {
        let d = `M ${points[0].x} ${points[0].y}`;
        for (let i = 1; i < points.length; i++) {
          const prev = points[i - 1];
          const cur = points[i];
          const cx = (prev.x + cur.x) / 2;
          d += ` Q ${prev.x} ${prev.y} ${cx} ${(prev.y + cur.y) / 2}`;
        }
        const last = points[points.length - 1];
        d += ` T ${last.x} ${last.y}`;
        graphLine.setAttribute('d', d);
        graphLine.setAttribute('stroke', accentColor);
      }
    }

    function drawParticles(dt) {
      if (!partCtx) return;
      partCtx.clearRect(0, 0, innerWidth, innerHeight);
      for (let p of particles) {
        p.x += p.vx * dt * 0.06;
        p.y += p.vy * dt * 0.06;
        p.alpha -= 0.0006 * dt;
        if (p.y < -20 || p.alpha <= 0) {
          p.x = Math.random() * innerWidth;
          p.y = innerHeight + 10 + Math.random() * 80;
          p.vx = (Math.random() - 0.5) * 0.2;
          p.vy = -0.1 - Math.random() * 0.6;
          p.size = 1 + Math.random() * 3;
          p.alpha = 0.06 + Math.random() * 0.18;
          p.color = Math.random() > 0.6 ? gainColor : 'rgba(255,255,255,0.06)';
        }
        partCtx.beginPath();
        partCtx.fillStyle = hexToRgba(p.color, p.alpha);
        partCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        partCtx.fill();
      }
    }

    function hexToRgba(input, alpha = 1) {
      input = (input || '').trim();
      if (!input) return `rgba(255,255,255,${alpha})`;
      if (input.startsWith('rgba')) return input;
      if (input.startsWith('rgb(')) {
        return input.replace('rgb(', 'rgba(').replace(')', `, ${alpha})`);
      }
      if (input[0] === '#') {
        let hex = input.slice(1);
        if (hex.length === 3) hex = hex.split('').map(h => h + h).join('');
        const num = parseInt(hex, 16);
        const r = (num >> 16) & 255;
        const g = (num >> 8) & 255;
        const b = num & 255;
        return `rgba(${r},${g},${b},${alpha})`;
      }
      return input;
    }

    // initial inits and loop
    resize();
    initParticles();
    createCoins();
    (function animateTicker() {
      if (!tickerText) return;
      const width = tickerText.offsetWidth;
      gsap.fromTo(tickerText, { x: 0 }, {
        x: -width - 60,
        duration: 18,
        ease: 'none',
        repeat: -1,
        modifiers: { x: gsap.utils.unitize(x => parseFloat(x) % (width + 60)) }
      });
    })();

    let last = performance.now();
    function loop(now) {
      const dt = now - last;
      last = now;
      drawBars(now);
      drawParticles(dt);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) gsap.globalTimeline.pause();
      else gsap.globalTimeline.resume();
    });
  </script>
</body>
</html>
