<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Horizon Labs — Présentation graphique (sparklines + barres)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#040512;
      --accent:#4a90e2;
      --muted:rgba(255,255,255,0.78);
      --card-bg:rgba(255,255,255,0.03);
      --card-strong:rgba(255,255,255,0.06);
      --border:rgba(255,255,255,0.08);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:#fff;background:var(--bg);-webkit-font-smoothing:antialiased;overflow-x:hidden}

    /* Scene */
    .scene{position:fixed;inset:0;z-index:0;overflow:hidden;pointer-events:none;background:linear-gradient(180deg,#02030a 0%,#040512 70%)}
    .scene::after{content:"";position:absolute;inset:0;background:rgba(0,0,0,0.66);z-index:2;pointer-events:none}
    canvas#hero{position:absolute;inset:0;width:100%;height:100%;z-index:1;display:block}

    /* Nav */
    nav{position:fixed;top:16px;left:0;right:0;z-index:1200;display:flex;justify-content:center;pointer-events:auto}
    .nav{width:1280px;max-width:96%;display:flex;justify-content:space-between;align-items:center;padding:10px 18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));backdrop-filter:blur(12px);border-radius:8px;border:1px solid var(--border)}
    .brand{font-weight:800;font-size:1.3rem}
    .brand span{color:var(--accent)}
    .links a{color:var(--muted);text-decoration:none;margin-left:20px;font-weight:500;transition:all .25s}
    .links a:hover{color:#fff}

    /* Hero header */
    .hero{min-height:56vh;display:flex;align-items:center;justify-content:center;position:relative;z-index:40;padding:0 20px;text-align:center}
    .hero-inner{max-width:980px;padding:36px;background:linear-gradient(180deg,var(--card-bg),var(--card-strong));border-radius:12px;backdrop-filter:blur(10px);border:1px solid var(--border)}
    h1{font-size:clamp(2rem,4.5vw,3.4rem);line-height:1.05;font-weight:800;margin-bottom:8px}
    .lead{font-size:clamp(1rem,1.6vw,1.05rem);color:var(--muted);margin-bottom:14px}

    /* KPI block now in the document flow, centered under hero */
    .kpi-row{
      position:relative;
      z-index:60;
      display:flex;
      justify-content:center;
      gap:18px;
      margin:18px auto;
      padding:8px;
      max-width:1100px;
      width:calc(100% - 40px);
      pointer-events:auto;
    }
    .kpi-card{
      min-width:160px;
      max-width:260px;
      padding:14px 18px;
      border-radius:10px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      box-shadow:0 6px 18px rgba(0,0,0,0.35);
    }
    .kpi-card h3{font-size:0.95rem;color:var(--muted);font-weight:600;margin-bottom:6px}
    .kpi-card .value{font-size:1.6rem;font-weight:800;color:#fff}

    /* Responsive: stack KPI into grid on small screens */
    @media (max-width:900px){
      .kpi-row{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;width:calc(100% - 28px);max-width:640px;margin:14px auto}
      .hero{min-height:48vh}
      .hero-inner{padding:20px}
    }

    /* Page content */
    .page-content{position:relative;z-index:70;max-width:980px;margin:20px auto 80px;padding:28px 20px}
    #seo-description{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:8px;padding:20px;border:1px solid rgba(255,255,255,0.04);color:var(--muted);line-height:1.6}
    footer{position:relative;z-index:60;padding:24px;text-align:center;color:var(--muted);font-size:0.85rem}
  </style>
</head>
<body>

  <div class="scene" aria-hidden="true">
    <canvas id="hero" aria-hidden="true"></canvas>
  </div>

  <nav>
    <div class="nav">
      <div class="brand">Horizon<span>Labs</span></div>
      <div class="links">
        <a class="disabled" aria-disabled="true">Accueil</a>
        <a href="portefeuilles.html">Portefeuilles</a>
        <a class="disabled" aria-disabled="true">Analyse</a>
        <a class="disabled" aria-disabled="true">Paramètres</a>
      </div>
    </div>
  </nav>

  <!-- Hero header -->
  <section class="hero" aria-hidden="false">
    <div class="hero-inner" role="region" aria-label="Présentation">
      <h1>Maîtrise financière, en toute simplicité.</h1>
      <p class="lead">Tableau de bord SaaS pour un survol en temps réel — KPIs essentiels et tendances procédurales.</p>
    </div>
  </section>

  <!-- KPI row placed in the flow under the hero so it scrolls with the page -->
  <div class="kpi-row" role="region" aria-label="Indicateurs clés">
    <div class="kpi-card" id="kpi-wallets">
      <h3>Portefeuilles</h3>
      <div class="value" id="walletsCount">—</div>
    </div>
    <div class="kpi-card" id="kpi-newsletters">
      <h3>Newsletters</h3>
      <div class="value" id="newslettersCount">—</div>
    </div>
    <div class="kpi-card" id="kpi-assets">
      <h3>Actifs distincts</h3>
      <div class="value" id="assetsCount">—</div>
    </div>
    <div class="kpi-card" id="kpi-visits">
      <h3>Visites (mois)</h3>
      <div class="value" id="visitsCount">1 234</div>
    </div>
  </div>

  <!-- Long descriptive text (≥10 lignes) -->
  <main class="page-content" aria-live="polite">
    <article id="seo-description">
      <h2 style="color:#fff;margin-bottom:10px;font-size:1.15rem;">À propos — Présentation graphique</h2>

      <p>Horizon Labs propose une interface claire et visuelle pour suivre vos portefeuilles et comprendre rapidement les dynamiques de marché. Cette page de démonstration met en avant un rendu graphique soigné : peu de lignes marquantes, aires floues et diagrammes en barre pour représenter le volume. Les éléments visuels sont pensés pour être lisibles sur fond sombre et pour attirer l’attention sur les KPIs au centre de l’écran.</p>

      <p>Le design privilégie l’espace et la hiérarchie : les sparklines larges racontent la tendance, les barres en bas matérialisent le volume, et les blobs flous apportent de la profondeur sans distraire. Les couleurs restent froides et professionnelles, avec des accents lumineux pour les points d’intérêt. L’ensemble est optimisé pour rester discret sur mobile tout en offrant un rendu premium sur desktop.</p>

      <p>Les animations sont lentes et organiques pour éviter la fatigue visuelle. Elles sont conçues pour être non intrusives : si l’utilisateur active la préférence de réduction d’animations, le rendu devient statique. Les KPIs restent accessibles et centraux, permettant une lecture immédiate des indicateurs clés.</p>

      <p>Ce rendu est idéal pour une page d’accueil produit, une démo commerciale ou un hero visuel sur une landing page. Il met l’accent sur la clarté des informations tout en offrant un impact esthétique fort, utile pour convaincre des décideurs ou présenter un produit financier.</p>

      <p>Sur le plan technique, le fond animé utilise un canvas performant, des gradients et des ombres contrôlées pour limiter l’usage CPU/GPU. Les barres sont volontairement plus marquées pour être lisibles même lorsque le visiteur parcourt la page rapidement.</p>

      <p>Enfin, la mise en page est responsive : les vignettes KPI se recentrent et se réorganisent automatiquement sur petits écrans, et la densité visuelle est réduite pour préserver la lisibilité et la batterie des appareils mobiles.</p>

      <p>Si tu veux, je peux brancher les barres sur une colonne volume réelle de ton CSV pour refléter des données réelles, ou ajuster la palette (par ex. vert/rouge) pour indiquer performance positive/négative.</p>

      <p>Je peux aussi fournir une version encore plus épurée (3 lignes + 6 barres larges) pour un rendu ultra‑minimaliste, ou une version « data » où chaque barre correspond à un secteur et chaque ligne à une moyenne mobile.</p>

      <p>Dis‑moi si tu veux que j’augmente encore le contraste des barres, que je réduise la lueur des lignes, ou que j’ajoute un toggle visible pour réduire les animations manuellement.</p>
    </article>
  </main>

  <footer>© 2025 Horizon Labs — Gestion SaaS privée</footer>

  <script>
    // KPI fetching (unchanged)
    const el = {
      wallets: document.getElementById('walletsCount'),
      newsletters: document.getElementById('newslettersCount'),
      assetsTotal: document.getElementById('assetsCount'),
      visits: document.getElementById('visitsCount'),
      kpiWalletsCard: document.getElementById('kpi-wallets'),
      kpiAssetsCard: document.getElementById('kpi-assets')
    };

    const portfoliosUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/portfolios.json';
    const compositionCsvUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/composition_portefeuilles.csv';
    const newslettersUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/newsletters.json';

    function parseCSV(text){
      const lines = text.split(/\r?\n/).filter(l=>l.trim()!=='');
      if(!lines.length) return {headers:[], rows:[]};
      const headerLine = lines[0];
      const delimiter = headerLine.includes('\t') ? '\t' : ',';
      const headers = headerLine.split(delimiter).map(h=>h.trim().replace(/^"|"$/g,''));
      const rows = lines.slice(1).map(line=>{
        const values=[]; let cur='', inQuotes=false;
        for(let i=0;i<line.length;i++){
          const ch=line[i];
          if(ch==='"'){ if(inQuotes && line[i+1]==='"'){ cur+='"'; i++; } else { inQuotes=!inQuotes; } continue; }
          if(ch===delimiter && !inQuotes){ values.push(cur); cur=''; continue; }
          cur+=ch;
        }
        values.push(cur);
        return values.map(v=>v.trim().replace(/^"|"$/g,''));
      });
      return {headers, rows};
    }

    async function updateKPIs(){
      try{
        const res = await fetch(portfoliosUrl, {cache:'no-store'});
        if(!res.ok) throw new Error('portfolios.json '+res.status);
        const data = await res.json();
        let count = Array.isArray(data) ? data.length : (data && typeof data==='object' ? (Object.values(data).find(v=>Array.isArray(v))||[]).length : 0);
        el.wallets.textContent = count.toLocaleString('fr-FR');
        el.kpiWalletsCard.classList.remove('kpi--error');
      }catch(e){ el.wallets.textContent='0'; el.kpiWalletsCard.classList.add('kpi--error'); }

      try{
        const res2 = await fetch(newslettersUrl, {cache:'no-store'});
        if(!res2.ok) throw new Error('newsletters.json '+res2.status);
        const ndata = await res2.json();
        let ncount = Array.isArray(ndata) ? ndata.length : (ndata && typeof ndata==='object' ? (Object.values(ndata).find(v=>Array.isArray(v))||[]).length : 0);
        el.newsletters.textContent = ncount.toLocaleString('fr-FR');
      }catch(e){ el.newsletters.textContent='0'; }

      try{
        const res3 = await fetch(compositionCsvUrl, {cache:'no-store'});
        if(!res3.ok) throw new Error('composition CSV '+res3.status);
        const csvText = await res3.text();
        const parsed = parseCSV(csvText);
        const headersLower = parsed.headers.map(h=>h.toLowerCase());
        const tickerIdx = headersLower.findIndex(h=>['ticker','symbole','symbol'].includes(h));
        if(tickerIdx===-1){ el.assetsTotal.textContent='0'; el.kpiAssetsCard.classList.add('kpi--error'); }
        else {
          const tickers = new Set();
          parsed.rows.forEach(r=>{ const t=(r[tickerIdx]||'').trim(); if(t) tickers.add(t.toUpperCase()); });
          el.assetsTotal.textContent = tickers.size.toLocaleString('fr-FR');
          el.kpiAssetsCard.classList.remove('kpi--error');
        }
      }catch(e){ el.assetsTotal.textContent='0'; el.kpiAssetsCard.classList.add('kpi--error'); }

      if(el.visits) el.visits.textContent = '1 234';
    }
    updateKPIs();
    setInterval(updateKPIs, 30000);

    /* Canvas animation (keeps continuous timeline so no visible freeze) */
    const canvas = document.getElementById('hero');
    const ctx = canvas.getContext('2d', { alpha: true });
    let DPR = Math.max(1, devicePixelRatio || 1);
    let W = innerWidth, H = innerHeight;
    const POINTS = 140;
    let startTime = performance.now();
    let blobs = [], bars = [], lines = [], animatedPoints = [], lastInitSize = {w:0,h:0};
    const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    function resizeCanvas(){
      DPR = Math.max(1, devicePixelRatio || 1);
      W = innerWidth; H = innerHeight;
      canvas.width = Math.round(W * DPR);
      canvas.height = Math.round(H * DPR);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);
      initScene();
    }
    window.addEventListener('resize', resizeCanvas);

    function initBlobs(){
      blobs = [];
      const count = 3;
      for(let i=0;i<count;i++){
        const size = Math.min(W,H) * (0.45 + Math.random()*0.35);
        blobs.push({ x: Math.random()*W, y: Math.random()*H*0.7, r: size, hue: 200 + Math.random()*80, alpha: 0.08 + Math.random()*0.18, vx: (Math.random()-0.5)*0.02, vy: (Math.random()-0.5)*0.02 });
      }
    }
    function initBars(){
      bars = [];
      const count = Math.max(10, Math.round(W / 120));
      for(let i=0;i<count;i++){
        bars.push({ x: (i + 0.5) * (W / count), w: Math.max(12, Math.floor(W / count * 0.72)), h: (0.18 + Math.random()*0.6) * (H * 0.18), hue: 210 + Math.random()*60, alpha: 0.36 + Math.random()*0.18 });
      }
    }
    function initLines(){
      lines = [];
      const marginTop = Math.max(120, H * 0.08);
      const marginBottom = Math.max(220, H * 0.18);
      const usable = Math.max(200, H - marginTop - marginBottom);
      const spacing = usable / Math.max(1, 3 - 1);
      for(let i=0;i<3;i++){
        const yBase = marginTop + i * spacing;
        const thickness = 2.6 + i * 0.8;
        const phase = Math.random()*Math.PI*2;
        const speed = 0.00025 + Math.random()*0.0009;
        const amplitude = 0.12 * (0.9 + Math.random()*0.6) * spacing;
        const colorHue = 200 + i * 28;
        const freq = 1 + i * 0.6;
        const base = new Float32Array(POINTS);
        for(let p=0;p<POINTS;p++) base[p] = Math.sin((p/POINTS)*Math.PI*2*freq) * (0.4 + Math.random()*0.8);
        lines.push({ yBase, thickness, phase, speed, amplitude, base, colorHue, freq });
      }
    }
    function initPoints(){
      animatedPoints = [];
      for(let i=0;i<lines.length;i++) animatedPoints.push({ lineIdx:i, xIndex: Math.floor(Math.random()*POINTS), phase: Math.random()*Math.PI*2, speed: 0.0008 + Math.random()*0.002 });
    }
    function initScene(){
      if(lastInitSize.w === W && lastInitSize.h === H && blobs.length && bars.length && lines.length) return;
      lastInitSize = {w:W,h:H};
      initBlobs(); initBars(); initLines(); initPoints();
    }

    function drawBlobs(elapsed){
      for(const b of blobs){
        b.x += b.vx * (elapsed * 0.00001);
        b.y += b.vy * (elapsed * 0.00001);
        if(b.x < -b.r) b.x = W + b.r;
        if(b.x > W + b.r) b.x = -b.r;
        if(b.y < -b.r) b.y = H + b.r;
        if(b.y > H + b.r) b.y = -b.r;
        const grd = ctx.createRadialGradient(b.x, b.y, b.r*0.05, b.x, b.y, b.r);
        const hue = b.hue; const alpha = b.alpha;
        grd.addColorStop(0, `hsla(${hue},90%,70%,${alpha*0.95})`);
        grd.addColorStop(0.25, `hsla(${hue},85%,60%,${alpha*0.6})`);
        grd.addColorStop(0.6, `hsla(${hue},80%,50%,${alpha*0.18})`);
        grd.addColorStop(1, `hsla(${hue},80%,40%,0)`);
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
      }
    }
    function drawBars(){
      const baseY = H - 48;
      for(const bar of bars){
        const g = ctx.createLinearGradient(bar.x - bar.w/2, baseY - bar.h, bar.x - bar.w/2, baseY);
        g.addColorStop(0, `hsla(${bar.hue},85%,45%,${Math.min(0.95, bar.alpha)})`);
        g.addColorStop(1, `hsla(${bar.hue},75%,30%,${Math.min(0.7, bar.alpha*0.9)})`);
        ctx.save(); ctx.shadowColor = `rgba(0,0,0,0.44)`; ctx.shadowBlur = 14; ctx.shadowOffsetY = 8;
        ctx.fillStyle = g; ctx.fillRect(bar.x - bar.w/2, baseY - bar.h, bar.w, bar.h); ctx.restore();
        ctx.beginPath(); ctx.lineWidth = 1; ctx.strokeStyle = `rgba(0,0,0,0.28)`; ctx.strokeRect(bar.x - bar.w/2 + 0.5, baseY - bar.h + 0.5, bar.w - 1, bar.h - 1);
      }
    }
    function drawLines(elapsed){
      for(let i=0;i<lines.length;i++){
        const s = lines[i];
        const t = elapsed * s.speed;
        const stepX = W / (POINTS - 1);
        const pts = new Array(POINTS);
        for(let p=0;p<POINTS;p++){
          const noise = s.base[p] * (0.45 + 0.55 * Math.sin(t + p * 0.12 + s.phase));
          const x = p * stepX;
          const y = s.yBase + noise * s.amplitude;
          pts[p] = {x,y};
        }
        ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
        for(let p=1;p<POINTS;p++) ctx.lineTo(pts[p].x, pts[p].y);
        const baseline = s.yBase + s.amplitude * 1.8;
        ctx.lineTo(W, baseline); ctx.lineTo(0, baseline); ctx.closePath();
        ctx.save(); ctx.shadowColor = `rgba(6,18,40,0.22)`; ctx.shadowBlur = 28; ctx.shadowOffsetY = 10;
        const fillGrad = ctx.createLinearGradient(0, s.yBase - s.amplitude, 0, baseline);
        fillGrad.addColorStop(0, `hsla(${s.colorHue},85%,55%,0.18)`); fillGrad.addColorStop(1, `hsla(${s.colorHue},80%,35%,0.02)`);
        ctx.fillStyle = fillGrad; ctx.fill(); ctx.restore();
        ctx.save(); ctx.lineJoin='round'; ctx.lineCap='round'; ctx.lineWidth = s.thickness + 2.4;
        ctx.shadowColor = `hsla(${s.colorHue},90%,70%,0.20)`; ctx.shadowBlur = 30; ctx.strokeStyle = `hsla(${s.colorHue},90%,70%,0.16)`;
        ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y); for(let p=1;p<POINTS;p++) ctx.lineTo(pts[p].x, pts[p].y); ctx.stroke(); ctx.restore();
        ctx.beginPath(); ctx.lineWidth = Math.max(1.6, s.thickness * 0.95); ctx.strokeStyle = `hsla(${s.colorHue},95%,92%,0.98)`;
        ctx.moveTo(pts[0].x, pts[0].y); for(let p=1;p<POINTS;p++) ctx.lineTo(pts[p].x, pts[p].y); ctx.stroke();
      }
    }
    function drawAnimatedPoints(elapsed){
      for(const ap of animatedPoints){
        const s = lines[ap.lineIdx];
        ap.phase += ap.speed * (elapsed * 0.00001);
        const idx = (Math.floor((ap.xIndex + Math.sin(ap.phase) * 6 + elapsed * 0.00002) + POINTS)) % POINTS;
        const stepX = W / (POINTS - 1);
        const noise = s.base[idx] * (0.45 + 0.55 * Math.sin(elapsed * s.speed + idx * 0.12 + s.phase));
        const x = idx * stepX; const y = s.yBase + noise * s.amplitude;
        ctx.save(); ctx.beginPath(); ctx.shadowColor = `hsla(${s.colorHue},95%,75%,0.34)`; ctx.shadowBlur = 22;
        ctx.fillStyle = `hsla(${s.colorHue},95%,75%,0.98)`; ctx.arc(x,y,6.0,0,Math.PI*2); ctx.fill(); ctx.restore();
        ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.98)'; ctx.arc(x,y,1.8,0,Math.PI*2); ctx.fill();
      }
    }

    let rafId = null;
    function animate(now){
      const elapsed = now - startTime;
      ctx.clearRect(0,0,W,H);
      const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'rgba(6,10,20,0.0)'); g.addColorStop(1,'rgba(6,10,20,0.12)');
      ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
      drawBlobs(elapsed); drawBars(); drawLines(elapsed); drawAnimatedPoints(elapsed);
      const vign = ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.12,W/2,H/2,Math.max(W,H)*0.9);
      vign.addColorStop(0,'rgba(0,0,0,0)'); vign.addColorStop(1,'rgba(0,0,0,0.45)');
      ctx.fillStyle = vign; ctx.fillRect(0,0,W,H);
      if(!reduceMotion) rafId = requestAnimationFrame(animate);
    }

    document.addEventListener('visibilitychange', ()=>{
      if(document.hidden){ if(rafId) cancelAnimationFrame(rafId); rafId = null; }
      else { if(!rafId && !reduceMotion) rafId = requestAnimationFrame(animate); }
    });

    function start(){
      resizeCanvas(); initScene();
      if(!reduceMotion) rafId = requestAnimationFrame(animate);
      else {
        const now = performance.now();
        const elapsed = now - startTime;
        drawBlobs(elapsed); drawBars(); drawLines(elapsed);
      }
    }
    window.addEventListener('load', start);
  </script>
</body>
</html>
