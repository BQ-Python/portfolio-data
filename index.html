<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Horizon Labs — Présentation Sparkline</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#040512;
      --accent:#4a90e2;
      --muted:rgba(255,255,255,0.78);
      --card-bg:rgba(255,255,255,0.03);
      --card-strong:rgba(255,255,255,0.06);
      --border:rgba(255,255,255,0.08);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:#fff;background:var(--bg);-webkit-font-smoothing:antialiased;overflow-x:hidden}

    /* Background scene */
    .scene{position:fixed;inset:0;z-index:0;overflow:hidden;pointer-events:none;background:linear-gradient(180deg,#02030a 0%,#040512 70%)}
    .scene::after{content:"";position:absolute;inset:0;background:rgba(0,0,0,0.66);z-index:2;pointer-events:none}
    canvas#hero{position:absolute;inset:0;width:100%;height:100%;z-index:1;display:block}

    /* Layout */
    nav{position:fixed;top:16px;left:0;right:0;z-index:1200;display:flex;justify-content:center;pointer-events:auto}
    .nav{width:1280px;max-width:96%;display:flex;justify-content:space-between;align-items:center;padding:10px 18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));backdrop-filter:blur(12px);border-radius:8px;border:1px solid var(--border)}
    .brand{font-weight:800;font-size:1.3rem}
    .brand span{color:var(--accent)}
    .links a{color:var(--muted);text-decoration:none;margin-left:20px;font-weight:500;transition:all .25s}
    .links a:hover{color:#fff}
    .links a.disabled{opacity:.5;pointer-events:none}

    .hero{min-height:56vh;display:flex;align-items:center;justify-content:center;position:relative;z-index:40;padding:0 20px;text-align:center}
    .hero-inner{max-width:980px;padding:36px;background:linear-gradient(180deg,var(--card-bg),var(--card-strong));border-radius:12px;backdrop-filter:blur(10px);border:1px solid var(--border)}
    h1{font-size:clamp(2rem,4.5vw,3.4rem);line-height:1.05;font-weight:800;margin-bottom:8px}
    .lead{font-size:clamp(1rem,1.6vw,1.05rem);color:var(--muted);margin-bottom:14px}

    .dashboard{position:relative;z-index:50;max-width:1280px;margin:0 auto 80px;padding:28px 20px;display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:18px}
    .kpi{background:linear-gradient(180deg,var(--card-bg),var(--card-strong));border-radius:10px;padding:18px;border:1px solid var(--border);transition:all .25s}
    .kpi h3{font-size:0.95rem;color:var(--muted);font-weight:500;margin-bottom:8px}
    .kpi .value{font-size:1.6rem;font-weight:800;color:#fff;display:block}

    #seo-description{grid-column:1 / -1;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:8px;padding:20px;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}

    footer{position:relative;z-index:60;padding:24px;text-align:center;color:var(--muted);font-size:0.85rem}

    @media (max-width:900px){
      .hero-inner{padding:20px}
      .dashboard{padding:20px 12px}
    }
  </style>
</head>
<body>

  <div class="scene" aria-hidden="true">
    <canvas id="hero" aria-hidden="true"></canvas>
  </div>

  <nav>
    <div class="nav">
      <div class="brand">Horizon<span>Labs</span></div>
      <div class="links">
        <a class="disabled" aria-disabled="true">Accueil</a>
        <a href="portefeuilles.html">Portefeuilles</a>
        <a class="disabled" aria-disabled="true">Analyse</a>
        <a class="disabled" aria-disabled="true">Paramètres</a>
      </div>
    </div>
  </nav>

  <section class="hero">
    <div class="hero-inner">
      <h1>Visuel Présentation — Tendances & Impact</h1>
      <p class="lead">Sparklines accentuées, aires floues et blobs pour un rendu magazine — idéal pour hero et démos.</p>
    </div>
  </section>

  <section class="dashboard" aria-live="polite" aria-atomic="true">
    <div class="kpi" id="kpi-wallets">
      <h3>Portefeuilles recensés</h3>
      <span class="value" id="walletsCount">—</span>
    </div>

    <div class="kpi" id="kpi-newsletters">
      <h3>Newsletters référencées</h3>
      <span class="value" id="newslettersCount">—</span>
    </div>

    <div class="kpi" id="kpi-assets">
      <h3>Actifs distincts disponibles</h3>
      <span class="value" id="assetsCount">—</span>
    </div>

    <div class="kpi" id="kpi-visits">
      <h3>Visites ce mois-ci</h3>
      <span class="value" id="visitsCount">1 234</span>
    </div>

    <article id="seo-description">
      <h2 style="color:#fff;margin-bottom:10px;font-size:1.15rem;">À propos — Présentation graphique</h2>
      <p style="line-height:1.5;color:var(--muted);">Version « Présentation » : peu de lignes, larges et marquantes, aires floues et blobs en arrière‑plan, glow prononcé. Conçue pour un impact visuel fort tout en conservant la lisibilité des KPIs.</p>
    </article>
  </section>

  <footer>© 2025 Horizon Labs — Gestion SaaS privée</footer>

  <script>
    /* -------------------------
       KPI fetching (kept minimal)
    ------------------------- */
    const el = {
      wallets: document.getElementById('walletsCount'),
      newsletters: document.getElementById('newslettersCount'),
      assetsTotal: document.getElementById('assetsCount'),
      visits: document.getElementById('visitsCount'),
      kpiWalletsCard: document.getElementById('kpi-wallets'),
      kpiAssetsCard: document.getElementById('kpi-assets')
    };

    const portfoliosUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/portfolios.json';
    const compositionCsvUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/composition_portefeuilles.csv';
    const newslettersUrl = 'https://raw.githubusercontent.com/BQ-Python/portfolio-data/refs/heads/main/newsletters.json';

    function parseCSV(text){
      const lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
      if(!lines.length) return {headers:[], rows:[]};
      const headerLine = lines[0];
      const delimiter = headerLine.includes('\t') ? '\t' : ',';
      const headers = headerLine.split(delimiter).map(h => h.trim().replace(/^"|"$/g,''));
      const rows = lines.slice(1).map(line=>{
        const values=[]; let cur='', inQuotes=false;
        for(let i=0;i<line.length;i++){
          const ch=line[i];
          if(ch==='"'){ if(inQuotes && line[i+1]==='"'){ cur+='"'; i++; } else { inQuotes=!inQuotes; } continue; }
          if(ch===delimiter && !inQuotes){ values.push(cur); cur=''; continue; }
          cur+=ch;
        }
        values.push(cur);
        return values.map(v=>v.trim().replace(/^"|"$/g,''));
      });
      return {headers, rows};
    }

    async function updateKPIs(){
      try{
        const res = await fetch(portfoliosUrl, {cache:'no-store'});
        if(!res.ok) throw new Error(`portfolios.json ${res.status}`);
        const data = await res.json();
        let count = 0;
        if(Array.isArray(data)) count = data.length;
        else if(data && typeof data === 'object'){ const arr = Object.values(data).find(v=>Array.isArray(v)); count = Array.isArray(arr)?arr.length:0; }
        el.wallets.textContent = count.toLocaleString('fr-FR');
        el.kpiWalletsCard.classList.remove('kpi--error');
      }catch(err){
        el.wallets.textContent = '0';
        el.kpiWalletsCard.classList.add('kpi--error');
      }

      try{
        const res2 = await fetch(newslettersUrl, {cache:'no-store'});
        if(!res2.ok) throw new Error(`newsletters.json ${res2.status}`);
        const ndata = await res2.json();
        let ncount = 0;
        if(Array.isArray(ndata)) ncount = ndata.length;
        else if(ndata && typeof ndata === 'object'){ const arr = Object.values(ndata).find(v=>Array.isArray(v)); ncount = Array.isArray(arr)?arr.length:0; }
        el.newsletters.textContent = ncount.toLocaleString('fr-FR');
      }catch(err){
        el.newsletters.textContent = '0';
      }

      try{
        const res3 = await fetch(compositionCsvUrl, {cache:'no-store'});
        if(!res3.ok) throw new Error(`composition_portefeuilles.csv ${res3.status}`);
        const csvText = await res3.text();
        const parsed = parseCSV(csvText);
        const headersLower = parsed.headers.map(h=>h.toLowerCase());
        const tickerIdx = headersLower.findIndex(h=>['ticker','symbole','symbol'].includes(h));
        if(tickerIdx === -1){
          el.assetsTotal.textContent = '0';
          el.kpiAssetsCard.classList.add('kpi--error');
          setVisualParams(4, 0.18, 0.18);
        } else {
          const tickers = new Set();
          parsed.rows.forEach(row=>{
            const t = (row[tickerIdx]||'').trim();
            if(!t) return;
            tickers.add(t.toUpperCase());
          });
          const total = tickers.size;
          el.assetsTotal.textContent = total.toLocaleString('fr-FR');
          el.kpiAssetsCard.classList.remove('kpi--error');
          // map number of assets to visual intensity (kept subtle for presentation)
          const lines = Math.min(6, Math.max(3, Math.round(3 + total * 0.04)));
          const amp = Math.min(0.5, 0.12 + Math.log10(Math.max(1,total)) * 0.04);
          const blobIntensity = Math.min(0.9, 0.12 + Math.log10(Math.max(1,total)) * 0.06);
          setVisualParams(lines, amp, blobIntensity);
        }
      }catch(err){
        el.assetsTotal.textContent = '0';
        el.kpiAssetsCard.classList.add('kpi--error');
        setVisualParams(4, 0.18, 0.18);
      }

      if(el.visits) el.visits.textContent = '1 234';
    }

    updateKPIs();
    setInterval(updateKPIs, 30000);

    /* -------------------------
       Hero canvas: Preset Présentation
       - 3..6 larges sparklines
       - thick strokes, filled blurred areas, big background blobs
       - glow (shadowBlur 24..40) and shadow under fills
       - animated points and occasional mini-volume bars
    ------------------------- */

    const canvas = document.getElementById('hero');
    const ctx = canvas.getContext('2d', { alpha: true });
    let DPR = Math.max(1, devicePixelRatio || 1);
    let W = innerWidth, H = innerHeight;

    // visual params (adjustable via setVisualParams)
    let VIS = {
      lines: 5,
      amplitudeFactor: 0.18,
      blobIntensity: 0.18
    };

    function setVisualParams(lines, amp, blobInt){
      VIS.lines = Math.max(3, Math.min(6, Math.round(lines)));
      VIS.amplitudeFactor = Math.max(0.06, Math.min(0.6, amp));
      VIS.blobIntensity = Math.max(0, Math.min(1, blobInt));
      initScene();
    }

    // respect reduced motion
    const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    function resize(){
      DPR = Math.max(1, devicePixelRatio || 1);
      W = innerWidth; H = innerHeight;
      canvas.width = Math.round(W * DPR);
      canvas.height = Math.round(H * DPR);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      initScene();
    }
    window.addEventListener('resize', resize);

    // blobs (big blurred background shapes)
    let blobs = [];
    function initBlobs(){
      blobs = [];
      const count = 3; // large soft blobs
      for(let i=0;i<count;i++){
        const size = Math.min(W,H) * (0.45 + Math.random() * 0.35);
        blobs.push({
          x: Math.random() * W,
          y: Math.random() * H * 0.7,
          r: size,
          hue: 200 + Math.random() * 80,
          alpha: 0.06 + Math.random() * 0.12,
          vx: (Math.random() - 0.5) * 0.02,
          vy: (Math.random() - 0.5) * 0.02
        });
      }
    }

    // sparklines
    let lines = [];
    const POINTS = 120; // resolution per line
    function initLines(){
      lines = [];
      const marginTop = Math.max(120, H * 0.08);
      const marginBottom = Math.max(120, H * 0.08);
      const usable = Math.max(200, H - marginTop - marginBottom);
      const spacing = usable / Math.max(1, VIS.lines - 1);
      for(let i=0;i<VIS.lines;i++){
        const yBase = marginTop + i * spacing;
        const thickness = 2.4 + Math.random() * 1.6; // 2.4..4.0 px
        const phase = Math.random() * Math.PI * 2;
        const speed = 0.00035 + Math.random() * 0.0009; // slow
        const amplitude = VIS.amplitudeFactor * (0.9 + Math.random() * 0.6) * spacing;
        const colorHue = 200 + i * 8; // slight hue shift
        // generate base noise
        const base = new Float32Array(POINTS);
        for(let p=0;p<POINTS;p++){
          base[p] = (Math.sin((p/POINTS) * Math.PI * 2 * (1 + Math.random()*0.6)) * (0.4 + Math.random()*0.8));
        }
        lines.push({ yBase, thickness, phase, speed, amplitude, base, colorHue });
      }
    }

    // animated points and mini-bars
    let animatedPoints = []; // {lineIdx, xIndex, phaseOffset}
    function initPoints(){
      animatedPoints = [];
      // one or two animated points per line
      for(let i=0;i<lines.length;i++){
        const count = 1 + Math.floor(Math.random()*2);
        for(let k=0;k<count;k++){
          animatedPoints.push({
            lineIdx: i,
            xIndex: Math.floor(Math.random() * POINTS),
            phase: Math.random() * Math.PI * 2,
            speed: 0.0008 + Math.random() * 0.002
          });
        }
      }
    }

    // mini-volume bars: sparse vertical bars under some x positions
    let miniBars = [];
    function initMiniBars(){
      miniBars = [];
      const barCount = Math.max(6, Math.round(W / 220));
      for(let i=0;i<barCount;i++){
        miniBars.push({
          x: Math.random() * W,
          height: Math.random() * (H * 0.06),
          alpha: 0.06 + Math.random() * 0.12,
          hue: 200 + Math.random() * 80
        });
      }
    }

    function initScene(){
      initBlobs();
      initLines();
      initPoints();
      initMiniBars();
    }

    // color helpers
    function hsl(h,s,l){ return `hsl(${h}, ${s}%, ${l}%)`; }
    function rgba(r,g,b,a){ return `rgba(${r},${g},${b},${a})`; }

    // draw blurred blob (large soft radial gradient)
    function drawBlobs(now){
      for(const b of blobs){
        // gentle movement
        b.x += b.vx * (now * 0.00002);
        b.y += b.vy * (now * 0.00002);
        // wrap
        if(b.x < -b.r) b.x = W + b.r;
        if(b.x > W + b.r) b.x = -b.r;
        if(b.y < -b.r) b.y = H + b.r;
        if(b.y > H + b.r) b.y = -b.r;

        // radial gradient with strong blur effect simulated by multiple stops
        const grd = ctx.createRadialGradient(b.x, b.y, b.r * 0.05, b.x, b.y, b.r);
        const hue = b.hue;
        const alpha = b.alpha * VIS.blobIntensity;
        grd.addColorStop(0, `hsla(${hue}, 90%, 70%, ${alpha * 0.95})`);
        grd.addColorStop(0.25, `hsla(${hue}, 85%, 60%, ${alpha * 0.6})`);
        grd.addColorStop(0.6, `hsla(${hue}, 80%, 50%, ${alpha * 0.18})`);
        grd.addColorStop(1, `hsla(${hue}, 80%, 40%, 0)`);
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
      }
    }

    // draw mini bars (very subtle)
    function drawMiniBars(){
      for(const mb of miniBars){
        ctx.beginPath();
        ctx.fillStyle = `hsla(${mb.hue}, 80%, 60%, ${mb.alpha})`;
        const w = Math.max(2, Math.round(W * 0.004));
        ctx.fillRect(mb.x - w/2, H - mb.height - 40, w, mb.height);
      }
    }

    // main draw: lines with filled area, shadow and glow
    function drawLines(now){
      for(let i=0;i<lines.length;i++){
        const s = lines[i];
        const t = now * s.speed;
        const stepX = W / (POINTS - 1);

        // compute path points
        const pts = new Array(POINTS);
        for(let p=0;p<POINTS;p++){
          const noise = s.base[p] * (0.5 + 0.5 * Math.sin(t + p * 0.14 + s.phase));
          const x = p * stepX;
          const y = s.yBase + noise * s.amplitude;
          pts[p] = { x, y };
        }

        // build area path
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let p=1;p<POINTS;p++) ctx.lineTo(pts[p].x, pts[p].y);
        // close to baseline to create fill
        const baseline = s.yBase + s.amplitude * 1.8;
        ctx.lineTo(W, baseline);
        ctx.lineTo(0, baseline);
        ctx.closePath();

        // shadow under filled area (soft, pronounced)
        ctx.save();
        ctx.shadowColor = `rgba(6,18,40,0.20)`;
        ctx.shadowBlur = 36; // strong shadow for presentation
        ctx.shadowOffsetY = 12;
        // gradient fill under curve
        const fillGrad = ctx.createLinearGradient(0, s.yBase - s.amplitude, 0, baseline);
        fillGrad.addColorStop(0, `hsla(${s.colorHue}, 85%, 65%, 0.18)`);
        fillGrad.addColorStop(1, `hsla(${s.colorHue}, 80%, 45%, 0.02)`);
        ctx.fillStyle = fillGrad;
        ctx.fill();
        ctx.restore();

        // glow stroke (outer)
        ctx.save();
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.lineWidth = s.thickness + 1.6;
        ctx.shadowColor = `hsla(${s.colorHue}, 90%, 70%, 0.20)`;
        ctx.shadowBlur = 28 + Math.random() * 12; // 24..40
        ctx.strokeStyle = `hsla(${s.colorHue}, 90%, 70%, 0.16)`;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let p=1;p<POINTS;p++) ctx.lineTo(pts[p].x, pts[p].y);
        ctx.stroke();
        ctx.restore();

        // crisp inner stroke
        ctx.beginPath();
        ctx.lineWidth = Math.max(1.2, s.thickness * 0.9);
        ctx.strokeStyle = `rgba(230,240,255,0.95)`;
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let p=1;p<POINTS;p++) ctx.lineTo(pts[p].x, pts[p].y);
        ctx.stroke();

        // subtle highlight line
        ctx.beginPath();
        ctx.lineWidth = Math.max(0.8, s.thickness * 0.45);
        ctx.strokeStyle = `hsla(${s.colorHue}, 95%, 80%, 0.12)`;
        ctx.moveTo(pts[0].x, pts[0].y - 0.8);
        for(let p=1;p<POINTS;p++) ctx.lineTo(pts[p].x, pts[p].y - 0.8);
        ctx.stroke();

        // small soft fill glow above baseline to add volume (very subtle)
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = `hsla(${s.colorHue}, 85%, 70%, 0.02)`;
        ctx.fillRect(0, baseline - 6, W, 6);
        ctx.restore();
      }
    }

    // draw animated points that travel along lines
    function drawAnimatedPoints(now){
      for(const ap of animatedPoints){
        const s = lines[ap.lineIdx];
        ap.phase += ap.speed * (now * 0.00002);
        // move index slowly
        const idx = (Math.floor((ap.xIndex + Math.sin(ap.phase) * 6 + now * 0.00002) + POINTS) ) % POINTS;
        const stepX = W / (POINTS - 1);
        const noise = s.base[idx] * (0.5 + 0.5 * Math.sin(now * s.speed + idx * 0.14 + s.phase));
        const x = idx * stepX;
        const y = s.yBase + noise * s.amplitude;
        // glow dot
        ctx.save();
        ctx.beginPath();
        ctx.shadowColor = `hsla(${s.colorHue}, 95%, 75%, 0.28)`;
        ctx.shadowBlur = 18;
        ctx.fillStyle = `hsla(${s.colorHue}, 95%, 75%, 0.95)`;
        ctx.arc(x, y, 4.2, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
        // crisp center
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.arc(x, y, 1.6, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // main render loop
    let last = performance.now();
    function render(now){
      const dt = now - last;
      last = now;
      // clear
      ctx.clearRect(0,0,W,H);

      // draw large blurred blobs in background
      drawBlobs(now);

      // draw mini bars near bottom (sparse)
      drawMiniBars();

      // draw sparklines with fills, shadows and glow
      drawLines(now);

      // animated points
      drawAnimatedPoints(now);

      // vignette to keep focus
      const vign = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.12, W/2, H/2, Math.max(W,H)*0.9);
      vign.addColorStop(0, 'rgba(0,0,0,0)');
      vign.addColorStop(1, 'rgba(0,0,0,0.45)');
      ctx.fillStyle = vign;
      ctx.fillRect(0,0,W,H);

      if(!reduceMotion) requestAnimationFrame(render);
    }

    // initialize everything
    function start(){
      resize();
      initScene();
      last = performance.now();
      if(reduceMotion){
        // draw a single static frame
        render(last);
      } else {
        requestAnimationFrame(render);
      }
    }

    // expose setter for debugging
    window.setVisualParams = setVisualParams;

    // start
    start();

    // pause/resume on visibility change
    document.addEventListener('visibilitychange', ()=>{
      if(document.hidden){
        // browser throttles rAF; nothing else needed
      } else {
        last = performance.now();
        if(!reduceMotion) requestAnimationFrame(render);
      }
    });
  </script>
</body>
</html>
